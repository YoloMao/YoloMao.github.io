<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Aspects解读（一）前言Aspects是一个基于runtime运行时实现的轻量级AOP编程库，整个库代码不足千行，但干货满满。 阅读本文前，希望你具备： 1.看过Block源码 2.了解过运行时 Aspects源码地址：Github(版本：Aspects v1.4.2) Block源码地址：libclosure-73&#x2F;Block_private.h runtime源码地址：objc4-750">
<meta property="og:type" content="article">
<meta property="og:title" content="Aspects解读（一）">
<meta property="og:url" content="http://yoursite.com/2019/11/28/Aspects%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="YoloMao的博客">
<meta property="og:description" content="Aspects解读（一）前言Aspects是一个基于runtime运行时实现的轻量级AOP编程库，整个库代码不足千行，但干货满满。 阅读本文前，希望你具备： 1.看过Block源码 2.了解过运行时 Aspects源码地址：Github(版本：Aspects v1.4.2) Block源码地址：libclosure-73&#x2F;Block_private.h runtime源码地址：objc4-750">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/12/23/a5dH6kqmGEXi8b4.png">
<meta property="article:published_time" content="2019-11-28T09:01:05.956Z">
<meta property="article:modified_time" content="2019-12-23T06:52:43.272Z">
<meta property="article:author" content="YoloMao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/12/23/a5dH6kqmGEXi8b4.png">

<link rel="canonical" href="http://yoursite.com/2019/11/28/Aspects%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Aspects解读（一） | YoloMao的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YoloMao的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/Aspects%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="YoloMao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YoloMao的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Aspects解读（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-28 17:01:05" itemprop="dateCreated datePublished" datetime="2019-11-28T17:01:05+08:00">2019-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-23 14:52:43" itemprop="dateModified" datetime="2019-12-23T14:52:43+08:00">2019-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Aspects解读（一）"><a href="#Aspects解读（一）" class="headerlink" title="Aspects解读（一）"></a>Aspects解读（一）</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Aspects是一个基于runtime运行时实现的轻量级AOP编程库，整个库代码不足千行，但干货满满。</p>
<p>阅读本文前，希望你具备：</p>
<p>1.看过Block源码</p>
<p>2.了解过运行时</p>
<p>Aspects源码地址：<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Github</a>(版本：Aspects v1.4.2)</p>
<p>Block源码地址：<a href="https://opensource.apple.com/source/libclosure/libclosure-73/Block_private.h.auto.html" target="_blank" rel="noopener">libclosure-73/Block_private.h</a></p>
<p>runtime源码地址：<a href="https://opensource.apple.com/source/objc4/objc4-750" target="_blank" rel="noopener">objc4-750</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p>
<a id="more"></a>

<p>感谢以下文章以及苹果文档给予我阅读源码上的帮助(侵删)：</p>
<p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<p><a href="https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html" target="_blank" rel="noopener">do…while(0)的妙用</a></p>
<p><a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">Objective-C中的消息与消息转发</a></p>
<p><a href="https://www.jianshu.com/p/1849068b7833" target="_blank" rel="noopener">探究Block之MethodSignature</a></p>
<p><a href="https://juejin.im/post/5a459f6c51882538fe6316d5" target="_blank" rel="noopener">你真的会判断_objc_msgForward_stret吗</a></p>
<p>这篇笔记主要是记录阅读Aspects源码时遇到的知识点以及思路分析整理，如有错误望指正！</p>
<p>那我们开始吧，首先介绍库中部分函数实现的知识点。</p>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Aspects.h&quot;</span><br><span class="line">#import &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;message.h&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_performLocked(dispatch_block_t block) &#123;</span><br><span class="line">    static OSSpinLock aspect_lock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">    OSSpinLockLock(&amp;aspect_lock);</span><br><span class="line">    block();</span><br><span class="line">    OSSpinLockUnlock(&amp;aspect_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSAtomic.h 引入自旋锁OSSpinLock，通过函数<code>aspect_performLocked</code>以保证线程安全。然而OSSpinLock存在<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">优先级反转问题</a>，苹果已在 iOS10 设其为deprecated，部分开发者提issue改为<code>os_unfair_lock</code>，作者<a href="https://github.com/steipete/Aspects/issues/128" target="_blank" rel="noopener">没有采纳</a>。</p>
<p>###do{}while(0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define AspectLog(...)</span><br><span class="line">&#x2F;&#x2F;#define AspectLog(...) do &#123; NSLog(__VA_ARGS__); &#125;while(0)</span><br><span class="line">#define AspectLogError(...) do &#123; NSLog(__VA_ARGS__); &#125;while(0)</span><br></pre></td></tr></table></figure>

<p>需要注意<code>do{}while(0)</code>的使用，这种定义方式在Linux内核等代码中大量使用，主要是为了<a href="https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html]" target="_blank" rel="noopener">多行宏定义</a>的实现。</p>
<p>###AspectInfo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里定义了AspectInfo类，遵循Aspects.h头文件中声明的&lt;AspectInfo&gt;协议，主要保留了hook的对象以及原始函数实现，instance用<code>unsafe_unretained</code>修饰，即对需要hook的实例对象或类对象弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)arguments &#123;</span><br><span class="line">    if (!_arguments) &#123;</span><br><span class="line">        _arguments &#x3D; self.originalInvocation.aspects_arguments;</span><br><span class="line">    &#125;</span><br><span class="line">    return _arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arguments通过懒加载获取，组装成数组的过程比较昂贵。库中创建了NSInvocation的分类Aspects，新增了<code>aspects_arguments</code>和<code>aspect_argumentAtIndex:</code>2个实例方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSInvocation (Aspects)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Thanks to the ReactiveCocoa team for providing a generic solution for this.</span><br><span class="line">- (id)aspect_argumentAtIndex:(NSUInteger)index &#123;</span><br><span class="line">	const char *argType &#x3D; [self.methodSignature getArgumentTypeAtIndex:index];</span><br><span class="line">	&#x2F;&#x2F; Skip const type qualifier.</span><br><span class="line">	if (argType[0] &#x3D;&#x3D; _C_CONST) argType++;</span><br><span class="line"></span><br><span class="line">#define WRAP_AND_RETURN(type) do &#123; type val &#x3D; 0; [self getArgument:&amp;val atIndex:(NSInteger)index]; return @(val); &#125; while (0)</span><br><span class="line">	if (strcmp(argType, @encode(id)) &#x3D;&#x3D; 0 || strcmp(argType, @encode(Class)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		__autoreleasing id returnObj;</span><br><span class="line">		[self getArgument:&amp;returnObj atIndex:(NSInteger)index];</span><br><span class="line">		return returnObj;</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(SEL)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        SEL selector &#x3D; 0;</span><br><span class="line">        [self getArgument:&amp;selector atIndex:(NSInteger)index];</span><br><span class="line">        return NSStringFromSelector(selector);</span><br><span class="line">    &#125; else if (strcmp(argType, @encode(Class)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        __autoreleasing Class theClass &#x3D; Nil;</span><br><span class="line">        [self getArgument:&amp;theClass atIndex:(NSInteger)index];</span><br><span class="line">        return theClass;</span><br><span class="line">        &#x2F;&#x2F; Using this list will box the number with the appropriate constructor, instead of the generic NSValue.</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(char)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(char);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(int)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(int);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(short)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(short);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(long long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(long long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned char)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned char);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned int)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned int);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned short)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned short);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned long long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned long long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(float)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(float);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(double)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(double);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(BOOL)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(BOOL);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(bool)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(BOOL);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(char *)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(const char *);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(void (^)(void))) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		__unsafe_unretained id block &#x3D; nil;</span><br><span class="line">		[self getArgument:&amp;block atIndex:(NSInteger)index];</span><br><span class="line">		return [block copy];</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		NSUInteger valueSize &#x3D; 0;</span><br><span class="line">		NSGetSizeAndAlignment(argType, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">		unsigned char valueBytes[valueSize];</span><br><span class="line">		[self getArgument:valueBytes atIndex:(NSInteger)index];</span><br><span class="line"></span><br><span class="line">		return [NSValue valueWithBytes:valueBytes objCType:argType];</span><br><span class="line">	&#125;</span><br><span class="line">	return nil;</span><br><span class="line">#undef WRAP_AND_RETURN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)aspects_arguments &#123;</span><br><span class="line">	NSMutableArray *argumentsArray &#x3D; [NSMutableArray array];</span><br><span class="line">	for (NSUInteger idx &#x3D; 2; idx &lt; self.methodSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">		[argumentsArray addObject:[self aspect_argumentAtIndex:idx] ?: NSNull.null];</span><br><span class="line">	&#125;</span><br><span class="line">	return [argumentsArray copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>aspect_argumentAtIndex:</code>大体上通过C函数strcmp判断参数类型是否相等，来获取对应index的参数，在<code>aspects_arguments</code>中组装到argumentArray中并返回。这里作者感谢ReactiveCocoa团队提供的通用解决方案。</p>
<p>###AspectIdentifier</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks a single aspect.</span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectIdentifier持有hook相关的信息，注意这里object是用weak修饰，即对hook对象弱引用。让我们看看初始化方法<code>identifierWithSelector:object:options:block:error:</code>的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error &#123;</span><br><span class="line">    NSCParameterAssert(block);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line">    NSMethodSignature *blockSignature &#x3D; aspect_blockMethodSignature(block, error); &#x2F;&#x2F; TODO: check signature compatibility, etc.</span><br><span class="line">    if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AspectIdentifier *identifier &#x3D; nil;</span><br><span class="line">    if (blockSignature) &#123;</span><br><span class="line">        identifier &#x3D; [AspectIdentifier new];</span><br><span class="line">        identifier.selector &#x3D; selector;</span><br><span class="line">        identifier.block &#x3D; block;</span><br><span class="line">        identifier.blockSignature &#x3D; blockSignature;</span><br><span class="line">        identifier.options &#x3D; options;</span><br><span class="line">        identifier.object &#x3D; object; &#x2F;&#x2F; weak</span><br><span class="line">    &#125;</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aspect_blockMethodSignature</code>获取blockSignature，然后判断与原始函数实现的兼容性，初始化identifier以及其属性并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout &#x3D; (__bridge void *)block;</span><br><span class="line">	if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	void *desc &#x3D; layout-&gt;descriptor;</span><br><span class="line">	desc +&#x3D; 2 * sizeof(unsigned long int);</span><br><span class="line">	if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">		desc +&#x3D; 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">	if (!desc) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	const char *signature &#x3D; (*(const char **)desc);</span><br><span class="line">	return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aspect_blockMethodSignature</code>主要步骤如下：</p>
<p>1.强转block为自定义的AspectBlockRef类型指针</p>
<p>2.通过与运算<code>layout-&gt;flags &amp; AspectBlockFlagsHasSignature</code>判断当前block是否包含签名</p>
<p>3.获取<code>layout-&gt;descriptor</code>的指针desc，指针地址加上 <code>2 * sizeof(unsigned long int)</code>，即reserved和size占用的内存地址大小</p>
<p>4.通过与运算<code>layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers</code>判断当前block是否拷贝到堆上，若成立，则desc指针地址再加上 <code>2 * sizeof(void *)</code>，即copy和dispose占用的内存地址大小</p>
<p>5.判断desc是否有值，通过<code>[NSMethodSignature signatureWithObjCTypes:]</code>返回签名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Block internals.</span><br><span class="line">typedef NS_OPTIONS(int, AspectBlockFlags) &#123;</span><br><span class="line">	AspectBlockFlagsHasCopyDisposeHelpers &#x3D; (1 &lt;&lt; 25),</span><br><span class="line">	AspectBlockFlagsHasSignature          &#x3D; (1 &lt;&lt; 30)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你阅读过Block的<a href="https://opensource.apple.com/source/libclosure/libclosure-73/Block_private.h.auto.html" target="_blank" rel="noopener">源码</a>，可以发现这里的枚举跟<code>Block_layout-&gt;flags</code>中<code>BLOCK_HAS_COPY_DISPOSE</code>和<code>BLOCK_HAS_SIGNATURE</code>值相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _AspectBlock &#123;</span><br><span class="line">	__unused Class isa;</span><br><span class="line">	AspectBlockFlags flags;</span><br><span class="line">	__unused int reserved;</span><br><span class="line">	void (__unused *invoke)(struct _AspectBlock *block, ...);</span><br><span class="line">	struct &#123;</span><br><span class="line">		unsigned long int reserved;</span><br><span class="line">		unsigned long int size;</span><br><span class="line">		&#x2F;&#x2F; requires AspectBlockFlagsHasCopyDisposeHelpers</span><br><span class="line">		void (*copy)(void *dst, const void *src);</span><br><span class="line">		void (*dispose)(const void *);</span><br><span class="line">		&#x2F;&#x2F; requires AspectBlockFlagsHasSignature</span><br><span class="line">		const char *signature;</span><br><span class="line">		const char *layout;</span><br><span class="line">	&#125; *descriptor;</span><br><span class="line">	&#x2F;&#x2F; imported variables</span><br><span class="line">&#125; *AspectBlockRef;</span><br></pre></td></tr></table></figure>

<p>AspectBlockRef跟源码中Block的结构体Block_layout的定义也是一致的。<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes" target="_blank" rel="noopener">__unused</a>代表这个函数或者变量可能不使用，避免产生GCC编译器警告。</p>
<p>回到<code>identifierWithSelector:object:options:block:error:</code>方法中，接下来通过<code>aspect_isCompatibleBlockSignature</code>判断block参数与原始SEL参数的兼容性，不兼容则返回nil。然后给实例对象identifier各个属性赋值并返回identifier，AspectIdentifier的初始化方法到此结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(blockSignature);</span><br><span class="line">    NSCParameterAssert(object);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line"></span><br><span class="line">    BOOL signaturesMatch &#x3D; YES;</span><br><span class="line">    NSMethodSignature *methodSignature &#x3D; [[object class] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    if (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果block的参数数量大于原方法的参数数量，不匹配</span><br><span class="line">        signaturesMatch &#x3D; NO;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if (blockSignature.numberOfArguments &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果block的参数数量大于1，即有id&lt;AspectInfo&gt;，取出并对比&#39;@&#39;，不是一个对象类型，就不匹配</span><br><span class="line">            const char *blockType &#x3D; [blockSignature getArgumentTypeAtIndex:1];</span><br><span class="line">            if (blockType[0] !&#x3D; &#39;@&#39;) &#123;</span><br><span class="line">                signaturesMatch &#x3D; NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对于 method，参数0位是 self，参数1位是 SEL。对于 blockSignature，参数0位是 block，参数1位是 id&lt;AspectInfo&gt;。我们从参数2位开始做比较。</span><br><span class="line">        &#x2F;&#x2F; block 的参数数量可以少于 method，没事儿。</span><br><span class="line">        if (signaturesMatch) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果以上都符合，那么从第2位参数开始对比数据类型</span><br><span class="line">            for (NSUInteger idx &#x3D; 2; idx &lt; blockSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">                const char *methodType &#x3D; [methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                const char *blockType &#x3D; [blockSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                &#x2F;&#x2F; 不能是可选数据类型</span><br><span class="line">                if (!methodType || !blockType || methodType[0] !&#x3D; blockType[0]) &#123;</span><br><span class="line">                    signaturesMatch &#x3D; NO; break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!signaturesMatch) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;Block signature %@ doesn&#39;t match %@.&quot;, blockSignature, methodSignature];</span><br><span class="line">        AspectError(AspectErrorIncompatibleBlockSignature, description);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-(BOOL)invokeWithInfo:(id\&lt;AspectInfo&gt;)info</code>方法即调用hook的block代码。这里再次检查了一遍参数数量（其实没必要），并从2位开始，逐一把原函数中的参数赋给blockInvocation，最后invokeWithTarget调用block的函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    NSInvocation *blockInvocation &#x3D; [NSInvocation invocationWithMethodSignature:self.blockSignature];</span><br><span class="line">    NSInvocation *originalInvocation &#x3D; info.originalInvocation;</span><br><span class="line">    NSUInteger numberOfArguments &#x3D; self.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 谨慎起见，我们也要检查挂钩注册（参数数量）</span><br><span class="line">    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; blockInvocation 中的 &#39;self&#39; 实际将是 AspectInfo (可选)</span><br><span class="line">    if (numberOfArguments &gt; 1) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	void *argBuf &#x3D; NULL;</span><br><span class="line">    for (NSUInteger idx &#x3D; 2; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        const char *type &#x3D; [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">		NSUInteger argSize;</span><br><span class="line">		NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line">        </span><br><span class="line">		if (!(argBuf &#x3D; reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);</span><br><span class="line">			return NO;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [blockInvocation invokeWithTarget:self.block];</span><br><span class="line">    </span><br><span class="line">    if (argBuf !&#x3D; NULL) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，一般的方法调用在运行时是通过消息转发机制来完成，即<a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">[receiver message]</a>的形式，最终都转换成<code>objc_msgSend(receiver, @selector(message))</code>这样的纯C调用。但是，block并没有实际意义上的selector，运行时该如何调用block函数实现呢。没错，就是通过<code>[NSInvocation invocationWithMethodSignature:]</code>和<code>[NSInvocation invokeWithTarget:]</code>2个方法，获取到block的<a href="https://www.jianshu.com/p/1849068b7833" target="_blank" rel="noopener">signature</a>后，生成blockInvocation对象，再来调用block。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)remove &#123;</span><br><span class="line">    return aspect_remove(self, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循&lt;AspectToken&gt;协议实现了remove方法。</p>
<h3 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks all aspects for an object&#x2F;class.</span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectsContainer是AspectIdentifier的容器。主要是存储一个对象或者一个类的所有Aspects hook代码。可以注意到这里用到了atomic原子性修饰3个AspectsArray（方法执行前/替换方法实现/方法执行后），保证3个Array的set、get方法读写安全。接下来我们看看AspectsContainer具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@implementation AspectsContainer</span><br><span class="line"></span><br><span class="line">- (BOOL)hasAspects &#123;</span><br><span class="line">    return self.beforeAspects.count &gt; 0 || self.insteadAspects.count &gt; 0 || self.afterAspects.count &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123;</span><br><span class="line">    NSParameterAssert(aspect);</span><br><span class="line">    NSUInteger position &#x3D; options&amp;AspectPositionFilter;</span><br><span class="line">    switch (position) &#123;</span><br><span class="line">        case AspectPositionBefore:  self.beforeAspects  &#x3D; [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">        case AspectPositionInstead: self.insteadAspects &#x3D; [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">        case AspectPositionAfter:   self.afterAspects   &#x3D; [(self.afterAspects  ?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)removeAspect:(id)aspect &#123;</span><br><span class="line">    for (NSString *aspectArrayName in @[NSStringFromSelector(@selector(beforeAspects)),</span><br><span class="line">                                        NSStringFromSelector(@selector(insteadAspects)),</span><br><span class="line">                                        NSStringFromSelector(@selector(afterAspects))]) &#123;</span><br><span class="line">        NSArray *array &#x3D; [self valueForKey:aspectArrayName];</span><br><span class="line">        NSUInteger index &#x3D; [array indexOfObjectIdenticalTo:aspect];</span><br><span class="line">        if (array &amp;&amp; index !&#x3D; NSNotFound) &#123;</span><br><span class="line">            NSMutableArray *newArray &#x3D; [NSMutableArray arrayWithArray:array];</span><br><span class="line">            [newArray removeObjectAtIndex:index];</span><br><span class="line">            [self setValue:newArray forKey:aspectArrayName];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, before:%@, instead:%@, after:%@&gt;&quot;, self.class, self, self.beforeAspects, self.insteadAspects, self.afterAspects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>hasAspects返回当前对象或者类对象是否有Aspects hook代码。</p>
<p>在<code>addAspects:withOptions:</code>实现中，通过与运算获取AspectOptions，set方法保证读写安全赋值给对应的AspectsArray。</p>
<p>在<code>removeAspect:</code>实现中，遍历3个array，KVC获取与设置array的值。用到了<a href="https://developer.apple.com/documentation/foundation/nsarray/1410847-indexofobjectidenticalto?language=objc" target="_blank" rel="noopener">indexOfObjectIdenticalTo:</a>快速获取aspect所在索引。相对于<code>indexOfObject:</code>，<code>indexOfObjectIdenticalTo:</code><a href="https://stackoverflow.com/questions/3167849/indexofobject-vs-indexofobjectidenticalto" target="_blank" rel="noopener">更快</a>(直接比较地址，而indexOfObject有个isEqual的过程)。</p>
<p>这里有个疑问，既然用atomic保证原子性，<code>addAspects:withOptions:</code>通过set方法保证了读写安全，<code>removeAspect:</code>中则用到了KVC来获取与重新赋值array，为什么不继续使用set、get方法来保证读写安全呢？</p>
<p>###AspectTracker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectTracker : NSObject</span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass;</span><br><span class="line">@property (nonatomic, strong) Class trackedClass;</span><br><span class="line">@property (nonatomic, readonly) NSString *trackedClassName;</span><br><span class="line">@property (nonatomic, strong) NSMutableSet *selectorNames;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;</span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectTracker顾名思义是切面追踪器。主要功能是为了判断当前类对象是否可以被hook，并对允许hook的类添加追踪器以便再次判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123;</span><br><span class="line">    static NSMutableDictionary *swizzledClassesDict;</span><br><span class="line">    static dispatch_once_t pred;</span><br><span class="line">    dispatch_once(&amp;pred, ^&#123;</span><br><span class="line">        swizzledClassesDict &#x3D; [NSMutableDictionary new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return swizzledClassesDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追踪器存储在静态变量swizzledClassesDict中，通过dispatch_once创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@implementation AspectTracker</span><br><span class="line"></span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        _trackedClass &#x3D; trackedClass;</span><br><span class="line">        _selectorNames &#x3D; [NSMutableSet new];</span><br><span class="line">        _selectorNamesToSubclassTrackers &#x3D; [NSMutableDictionary new];&#x2F;&#x2F; &lt;NSString: NSMutableSet&lt;AspectTracker&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    return self.selectorNamesToSubclassTrackers[selectorName] !&#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *trackerSet &#x3D; self.selectorNamesToSubclassTrackers[selectorName];</span><br><span class="line">    if (!trackerSet) &#123;</span><br><span class="line">        trackerSet &#x3D; [NSMutableSet new];</span><br><span class="line">        self.selectorNamesToSubclassTrackers[selectorName] &#x3D; trackerSet;</span><br><span class="line">    &#125;</span><br><span class="line">    [trackerSet addObject:subclassTracker];</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *trackerSet &#x3D; self.selectorNamesToSubclassTrackers[selectorName];</span><br><span class="line">    [trackerSet removeObject:subclassTracker];</span><br><span class="line">    if (trackerSet.count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        [self.selectorNamesToSubclassTrackers removeObjectForKey:selectorName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *hookingSubclassTrackers &#x3D; [NSMutableSet new];</span><br><span class="line">    &#x2F;&#x2F;递归获取所有当前类的子类相对于该SEL的跟踪器，若tracker.selectorNames包含该SEL name，则添加到hookingSubclassTrackers集合中</span><br><span class="line">    for (AspectTracker *tracker in self.selectorNamesToSubclassTrackers[selectorName]) &#123;</span><br><span class="line">        if ([tracker.selectorNames containsObject:selectorName]) &#123;</span><br><span class="line">            [hookingSubclassTrackers addObject:tracker];</span><br><span class="line">        &#125;</span><br><span class="line">        [hookingSubclassTrackers unionSet:[tracker subclassTrackersHookingSelectorName:selectorName]];</span><br><span class="line">    &#125;</span><br><span class="line">    return hookingSubclassTrackers;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)trackedClassName &#123;</span><br><span class="line">    return NSStringFromClass(self.trackedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %@, trackedClass: %@, selectorNames:%@, subclass selector names: %@&gt;&quot;, self.class, self, NSStringFromClass(self.trackedClass), self.selectorNames, self.selectorNamesToSubclassTrackers.allKeys];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>initWithTrackedClass:</code>传入类初始化AspectTracker，<code>_trackedClass</code>为当前跟踪的类，用于trackedClassName方法返回类名；<code>_selectorNames</code>存储在当前类hook的selectorName； <code>_selectorNamesToSubclassTrackers</code>结构为<code>&lt;NSString: NSMutableSet&lt;AspectTracker&gt;&gt;</code>，即key为selectorName，value为<code>NSMutableSet&lt;AspectTracker&gt;</code>(所有子类对该SEL的追踪器)的可变字典。</p>
<p><code>subclassHasHookedSelectorName:</code>判断当前SEL是否在子类被Hook。</p>
<p><code>addSubclassTracker:hookingSelectorName:</code>添加子类SEL追踪器到字典selectorNamesToSubclassTrackers。</p>
<p><code>removeSubclassTracker:hookingSelectorName:</code>删除子类SEL追踪器。若追踪器set集合count为0，从字典selectorNamesToSubclassTrackers删除key(selectorName)对应NSMutableSet。</p>
<p><code>subclassTrackersHookingSelectorName</code>用来获取当前SEL的所有源追踪器，也就是说获取当前SEL在哪些子类被hook。</p>
<p>追踪器的实现比较绕，分为2种：</p>
<p>1.在当前类被hook的话，添加到selectorNames中；</p>
<p>2.在当前类的子类被hook的话，添加到selectorNamesToSubclassTrackers中。</p>
<p>以下是AspectTracker追踪器在<code>aspect_isSelectorAllowedAndTrack</code>方法中的实现流程图，建议结合代码理解。</p>
<p><img src="https://i.loli.net/2019/12/23/a5dH6kqmGEXi8b4.png" alt="Aspects-AspectTracker实现原理.jpg"></p>
<p>###aspect_isMsgForwardIMP和aspect_getMsgForwardIMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static BOOL aspect_isMsgForwardIMP(IMP impl) &#123;</span><br><span class="line">    return impl &#x3D;&#x3D; _objc_msgForward</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line">    || impl &#x3D;&#x3D; (IMP)_objc_msgForward_stret</span><br><span class="line">#endif</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) &#123;</span><br><span class="line">    IMP msgForwardIMP &#x3D; _objc_msgForward;</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line">    &#x2F;&#x2F; As an ugly internal runtime implementation detail in the 32bit runtime, we need to determine of the method we hook returns a struct or anything larger than id.</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;mac&#x2F;documentation&#x2F;DeveloperTools&#x2F;Conceptual&#x2F;LowLevelABI&#x2F;000-Introduction&#x2F;introduction.html</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ReactiveCocoa&#x2F;ReactiveCocoa&#x2F;issues&#x2F;783</span><br><span class="line">    &#x2F;&#x2F; http:&#x2F;&#x2F;infocenter.arm.com&#x2F;help&#x2F;topic&#x2F;com.arm.doc.ihi0042e&#x2F;IHI0042E_aapcs.pdf (Section 5.4)</span><br><span class="line">    Method method &#x3D; class_getInstanceMethod(self.class, selector);</span><br><span class="line">    const char *encoding &#x3D; method_getTypeEncoding(method);</span><br><span class="line">    BOOL methodReturnsStructValue &#x3D; encoding[0] &#x3D;&#x3D; _C_STRUCT_B;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            NSUInteger valueSize &#x3D; 0;</span><br><span class="line">            NSGetSizeAndAlignment(encoding, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">            if (valueSize &#x3D;&#x3D; 1 || valueSize &#x3D;&#x3D; 2 || valueSize &#x3D;&#x3D; 4 || valueSize &#x3D;&#x3D; 8) &#123;</span><br><span class="line">                methodReturnsStructValue &#x3D; NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @catch (__unused NSException *e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        msgForwardIMP &#x3D; (IMP)_objc_msgForward_stret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return msgForwardIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aspects中，arm64CPU架构下只用_objc_msgForward，建议看这篇<a href="https://juejin.im/post/5a459f6c51882538fe6316d5" target="_blank" rel="noopener">文章</a>理解。这2个函数实现主要在<code>aspect_prepareClassAndHookSelector</code>中用到，通过将selector对应IMP替换成 _objc_msgForward或者 _objc_msgForward_stret，可以触发消息转发，从而进入forwardInvocation的实现。</p>
<h3 id="aspect-invoke"><a href="#aspect-invoke" class="headerlink" title="aspect_invoke"></a>aspect_invoke</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define aspect_invoke(aspects, info) \</span><br><span class="line">for (AspectIdentifier *aspect in aspects) &#123;\</span><br><span class="line">    [aspect invokeWithInfo:info];\</span><br><span class="line">    if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span><br><span class="line">        aspectsToRemove &#x3D; [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者为了调试方便，把调用hook代码的过程替换成一个多行的宏定义。</p>
<p>接下来的部分将涉及到aspect_hookClass等的实现原理，由于篇幅过长，下一篇再进行分析。</p>
<p>这里是3篇比较好的文章：</p>
<p><a href="http://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">面向切面编程之 Aspects 源码解析及应用</a></p>
<p><a href="[https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%E4%B8%8EAspects%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md](https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/消息转发机制与Aspects源码解析.md)">消息转发机制与Aspects源码解析</a></p>
<p><a href="https://halfrost.com/ios_aspect/" target="_blank" rel="noopener">iOS如何实现 Aspect Oriented Programming</a></p>
<p>另：流程图、思维导图用<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>在线作图。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2019/12/17/%E6%B5%8B%E8%AF%95%E4%BB%BB%E6%84%8F%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9C%89%E6%95%88%E7%9A%84Objective-C%E5%AF%B9%E8%B1%A1/" rel="next" title="测试任意指针是否为有效的Objective-C对象">
      测试任意指针是否为有效的Objective-C对象 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Aspects解读（一）"><span class="nav-number">1.</span> <span class="nav-text">Aspects解读（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.0.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSSpinLock"><span class="nav-number">1.0.2.</span> <span class="nav-text">OSSpinLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AspectsContainer"><span class="nav-number">1.0.3.</span> <span class="nav-text">AspectsContainer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aspect-invoke"><span class="nav-number">1.0.4.</span> <span class="nav-text">aspect_invoke</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="YoloMao"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">YoloMao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YoloMao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
