<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tagged Pointer in iOS</title>
    <url>/uncategorized/Tagged%20Pointer%20in%20iOS/</url>
    <content><![CDATA[<h1 id="Tagged-Pointer-in-iOS"><a href="#Tagged-Pointer-in-iOS" class="headerlink" title="Tagged Pointer in iOS"></a>Tagged Pointer in iOS</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>问题1：下面的代码输出是什么？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSNumber</span> *weakNumber;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *weakString;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSDate</span> *weakDate;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    weakObj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    weakNumber = [<span class="built_in">NSNumber</span> numberWithInt:num];</span><br><span class="line">    weakString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"string%d"</span>, num];</span><br><span class="line">    weakDate   = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakObj is %@"</span>, weakObj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakNumber is %@"</span>, weakNumber);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakString is %@"</span>, weakString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakDate is %@"</span>, weakDate);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>问题2：下面的代码1、2会崩溃吗？如何解决？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghijklmn"</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题3：下面的代码1、2会崩溃吗？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>) </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> someProperty; </span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>) </span></span><br><span class="line"><span class="keyword">@dynamic</span> someProperty; </span><br><span class="line">- (<span class="keyword">void</span>)setSomeProperty:(<span class="built_in">CGFloat</span>)someProperty&#123; </span><br><span class="line">   <span class="keyword">return</span> objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(someProperty), @(someProperty), OBJC_ASSOCIATION_ASSIGN); </span><br><span class="line">&#125; </span><br><span class="line">- (<span class="built_in">CGFloat</span>)someProperty&#123; </span><br><span class="line">   <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(someProperty)) floatValue]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">self</span>.view.someProperty = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, @(<span class="keyword">self</span>.view.someProperty));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">self</span>.view.someProperty = <span class="number">100.1</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, @(<span class="keyword">self</span>.view.someProperty));</span><br></pre></td></tr></table></figure>

<p>带着这3个问题，我们先来了解一下Tagged Pointer这一概念。</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>（本篇文章基于<a href="https://opensource.apple.com/source/objc4/objc4-750/" target="_blank" rel="noopener">objc4-750</a>版本，由于objc源码版本更新迭代，部分内容与参考文章有出入。）</p>
<p>Tagged Pointer这一概念最早是在<a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/" target="_blank" rel="noopener">objc4-493.9</a>中出现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__  &amp;&amp;  __LP64__</span></span><br><span class="line"><span class="comment">// Register a tagged pointer class.</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> _objc_insert_tagged_isa(<span class="keyword">unsigned</span> <span class="keyword">char</span> slotNumber, Class isa)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在64位架构下，普通变量如NSInteger所占用的内存由32位架构下的4字节变成8个字节，NSNumber对象指针由32位架构下的4字节变成8字节，对象指针所指向的内存地址由32位架构下的8字节变成16字节，这带来的内存占用简直是灾难性的。</p>
<p>所以，从Mac OS X 10.7和iOS 5开始（64位），苹果同步提出了Tagged Pointer这样一个技巧，来优化NSNumber、NSString等对象类型，提升读取速度和减少其内存使用，具体的如唐巧老师这一篇<a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">文章</a>中写道：</p>
<blockquote>
<ol>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate。</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ol>
</blockquote>
<p>如下图，未引入Tagged Pointer以及引入Tagged Pointer下的内存占用情况：</p>
<p><img src="https://i.loli.net/2019/12/23/VgFw2tWqhKzneH6.png" alt="Tagged Pointer.jpg"></p>
<p>(备注：Tagged Pointer的布局随着不同的iOS版本而变化)</p>
<p>也就是说，当数据作为标记指针被优化时，该指针存储在栈上；没有isa指针，不是一个对象，以Tag + Payload的形式存储，且不需要编译器添加Retain和Release来做内存管理；占用的内存空间约为原来的1/3，读取、创建效率提升明显；如果60bits的payload无法完全表达数据，数据还是将会作为对象指针指向堆上的内存地址的形式存储。</p>
<p>那上面3个问题的答案就显而易见了：</p>
<p>问题1：除weakObj为null，其余3个的值都能正常打印。</p>
<p>问题2：代码1部分将崩溃（如果不崩溃请改为10000），系多线程异步并发执行多次release旧值导致crash，可以通过加锁来解决；代码2不会崩溃，因为对于标记指针将不作内存管理，直接赋值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__attribute__((aligned(<span class="number">16</span>)))</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题3：<a href="[http://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88](http://zh.wikipedia.org/wiki/迷途指针)">悬垂指针</a>调用crash，跟问题1的考察点一致，详见<a href="https://juejin.im/post/5bd3e59e51882578247082d3" target="_blank" rel="noopener">问题来源</a>作者的描述。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>上述3个问题分别来自（侵删），感谢作者：</p>
<ul>
<li><a href="https://wenghengcong.com/posts/b6becb26/" target="_blank" rel="noopener">内存管理（二）Tagged Pointer</a> by wenghengcong</li>
<li><a href="https://juejin.im/post/5c931b59e51d45733067e6b9" target="_blank" rel="noopener">小码哥iOS学习笔记第二十四天:Tagged Pointer</a> by SketchK</li>
<li><a href="https://juejin.im/post/5bd3e59e51882578247082d3" target="_blank" rel="noopener">由Tagged Pointer联想到的一个问题</a> by 冰凌天</li>
</ul>
<p>另外：</p>
<p><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">深入理解Tagged Pointer</a> by 唐巧</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Friday Q&amp;A 2012-07-27:Let’s Build Tagged Pointers</a> by Mike Ash</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">Friday Q&amp;A 2015-07-31:Tagged Pointer Strings</a> by Mike Ash <a href="http://www.cocoachina.com/articles/13449" target="_blank" rel="noopener">翻译</a></p>
<h3 id="iOS12"><a href="#iOS12" class="headerlink" title="iOS12"></a>iOS12</h3><p>然而，问题并没有结束。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n %p %@"</span>, string, [string <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>上述代码在iPhone6s真机(iOS12)下调试，打印为：</p>
<p><code>0x87c2ce80a4d444ae NSTaggedPointerString</code></p>
<p>这是什么跟什么？！！等等，按照上文分析以及<a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">Friday Q&amp;A 2015-07-31:Tagged Pointer Strings</a>里描述的，<code>@&quot;a&quot;</code>的对象指针地址应该是<code>0x?????????????61?</code>才对啊！！不信邪的再次运行：</p>
<p>0xcc5f2b03900c91ce NSTaggedPointerString</p>
<p>:slightly_smiling_face:</p>
<p>变了！！！不得了不得了！</p>
<p>尝试在iPhone5s模拟器(iOS10)上运行：</p>
<p><code>0xa000000000000611 NSTaggedPointerString</code></p>
<p>iPhone5s模拟器(iOS11)：</p>
<p><code>0xa000000000000611 NSTaggedPointerString</code></p>
<p>看来问题就出在iOS12上，让我们结合源码来解读。</p>
<h4 id="initializeTaggedPointerObfuscator"><a href="#initializeTaggedPointerObfuscator" class="headerlink" title="initializeTaggedPointerObfuscator"></a>initializeTaggedPointerObfuscator</h4><p>让我们从源码(<a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-runtime-new.mm.auto.html" target="_blank" rel="noopener">objc4-750 objc-runtime-new.mm</a>)中了解。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* initializeTaggedPointerObfuscator</span></span><br><span class="line"><span class="comment">* Initialize objc_debug_taggedpointer_obfuscator with randomness.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The tagged pointer obfuscator is intended to make it more difficult</span></span><br><span class="line"><span class="comment">* for an attacker to construct a particular object as a tagged pointer,</span></span><br><span class="line"><span class="comment">* in the presence of a buffer overflow or other write control over some</span></span><br><span class="line"><span class="comment">* memory. The obfuscator is XORed with the tagged pointers when setting</span></span><br><span class="line"><span class="comment">* or retrieving payload values. They are filled with randomness on first</span></span><br><span class="line"><span class="comment">* use.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">initializeTaggedPointerObfuscator(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdkIsOlderThan(<span class="number">10</span>_14, <span class="number">12</span>_0, <span class="number">12</span>_0, <span class="number">5</span>_0, <span class="number">3</span>_0) ||</span><br><span class="line">        <span class="comment">// Set the obfuscator to zero for apps linked against older SDKs,</span></span><br><span class="line">        <span class="comment">// in case they're relying on the tagged pointer representation.</span></span><br><span class="line">        DisableTaggedPointerObfuscation) &#123;</span><br><span class="line">        objc_debug_taggedpointer_obfuscator = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Pull random data into the variable, then shift away all non-payload bits.</span></span><br><span class="line">        arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,</span><br><span class="line">                       <span class="keyword">sizeof</span>(objc_debug_taggedpointer_obfuscator));</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &amp;= ~_OBJC_TAG_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，源码中用到了混淆器函数initializeTaggedPointerObfuscator来对标记指针做异或运算处理，以避免攻击者在缓冲区溢出以及其他可写控制内存伪造标记指针。在iOS12.0之前的版本将不做处理。</p>
<p>Product -&gt; Scheme -&gt; Edit Scheme或者按<code>command + shift + ,</code>(即<code>command + &lt;</code>)，在Arguments添加环境变量(Environment Variables)name为<code>OBJC_DISABLE_TAG_OBFUSCATION</code>，值为<code>YES</code>。</p>
<p>再次在iPhone6s真机(iOS12)下调试，打印为：</p>
<p><code>0xa000000000000611 NSTaggedPointerString</code></p>
<p>正常了！</p>
<h4 id="源码中其他有意思的地方"><a href="#源码中其他有意思的地方" class="headerlink" title="源码中其他有意思的地方"></a>源码中其他有意思的地方</h4><h5 id="LP64"><a href="#LP64" class="headerlink" title="__LP64__"></a>__LP64__</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_HAVE_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在为64位运行时进行编译时，编译器定义<a href="https://stackoverflow.com/questions/18861046/how-to-determine-if-compiling-for-64-bit-ios-in-xcode" target="_blank" rel="noopener">__LP64__</a>宏。这里通过__LP64__宏来判断是否有标记指针。</p>
<h5 id="MSB和LSB"><a href="#MSB和LSB" class="headerlink" title="MSB和LSB"></a>MSB和LSB</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>MSB(Most Significant Bit)：最高有效位，对数值的影响最大；LSB(Least Significant Bit)：最低有效位。参考：<a href="https://www.cnblogs.com/lingyejun/p/8312838.html" target="_blank" rel="noopener">清晰讲解LSB、MSB和大小端模式及网络字节序</a>。这里对标记指针的内部空间分配进行管理，在Mac上调试，字符串<code>@&quot;a&quot;</code>的标记指针地址为<code>0x6115</code>，tag和tag index从最低有效位开始；iPhone上调试，tag和tag index从最高有效位开始，如下图所示，<code>1010</code>即tag + tag index(<code>OBJC_TAG_NSString = 2</code>)。</p>
<p><img src="https://i.loli.net/2019/12/20/4Unysd2SD3Kr8of.png" alt="WX20191220-113101@2x.png"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="keyword">enum</span> objc_tag_index_t : uint16_t</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> uint16_t objc_tag_index_t;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 60-bit payloads</span></span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 60-bit reserved</span></span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 52-bit payloads</span></span><br><span class="line">    OBJC_TAG_Photos_1          = <span class="number">8</span>,</span><br><span class="line">    OBJC_TAG_Photos_2          = <span class="number">9</span>,</span><br><span class="line">    OBJC_TAG_Photos_3          = <span class="number">10</span>,</span><br><span class="line">    OBJC_TAG_Photos_4          = <span class="number">11</span>,</span><br><span class="line">    OBJC_TAG_XPC_1             = <span class="number">12</span>,</span><br><span class="line">    OBJC_TAG_XPC_2             = <span class="number">13</span>,</span><br><span class="line">    OBJC_TAG_XPC_3             = <span class="number">14</span>,</span><br><span class="line">    OBJC_TAG_XPC_4             = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  &amp;&amp;  !defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> objc_tag_index_t objc_tag_index_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>如有补充，日后再说。</p>
]]></content>
  </entry>
  <entry>
    <title>测试任意指针是否为有效的Objective-C对象</title>
    <url>/uncategorized/%E6%B5%8B%E8%AF%95%E4%BB%BB%E6%84%8F%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9C%89%E6%95%88%E7%9A%84Objective-C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>#测试任意指针是否为有效的Objective-C对象</p>
<p>翻译自：<a href="https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/" target="_blank" rel="noopener">https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/</a></p>
<p>仅供学习交流，侵删。</p>
<a id="more"></a>

<h2 id="以下为正文内容："><a href="#以下为正文内容：" class="headerlink" title="以下为正文内容："></a>以下为正文内容：</h2><p>假设你随机选取一个指针，我们能否知道它是否指向有效的Objective-C对象？当然不能有崩溃。。。emm，没有简单的解决方案。在这篇文章中，我给出了64位结构的解决方案。其提供的代码只在具有modern Objective-C运行时的macOS10.12.1和iOS10.1.1上测试过。</p>
<p>没有太多关于这个问题的文档。这里有一篇来自<a href="https://www.cocoawithlove.com/2010/10/testing-if-arbitrary-pointer-is-valid.html" target="_blank" rel="noopener">Matt Gallagher</a>的文章，写于2010年，但其中的内容已经过时且可能不能够正常使用。本文的大部分信息来自于：</p>
<p><a href="https://opensource.apple.com/source/objc4/objc4-706/" target="_blank" rel="noopener">objc4-706 from macOS10.12</a></p>
<p><a href="http://lldb.llvm.org/source.html" target="_blank" rel="noopener">LLDB git repository(November 2016)</a></p>
<p>###免责声明</p>
<p>本文的内容以及源代码依赖于Objective-C运行时的内部结构。对其正确性无法保证，并可能会随着macOS/iOS的更新而破坏。不要在实际App中使用这代码！</p>
<p>实际上我刚刚开始是基于objc4-680(mac OS 10.11.6)源码写这篇文章。但在发布前，苹果发布了objc4-706(macOS 10.12)的源码。正如下方图片所见，一些依赖的内部结构发生了改变：</p>
<p><img src="https://i.loli.net/2019/12/17/4wyCSTl1iHesEIY.png" alt="objc4-680_objc4-706.png"></p>
<h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针是引用某个内存地址的整数。然而，在iOS和macOS上，有2种指针：普通指针和标记指针。让我们开始解决标记指针的问题。</p>
<h3 id="标记指针"><a href="#标记指针" class="headerlink" title="标记指针"></a>标记指针</h3><p>在iOS7和Mac OS X 10.7 64位架构，引进了标记指针。带标记的指针是一种特殊的指针，其数据直接存储在该指针中，而不是通过内存分配。其具有明显的性能优势。</p>
<p>标记指针在objc-internal.h中声明。在macOS 10.11以及更早的版本中，标记指针较为简单：</p>
<ul>
<li><p>60位的有效载荷</p>
</li>
<li><p>3位的标记索引</p>
</li>
<li><p>1位用来辨别标记指针对象或普通对象</p>
</li>
</ul>
<p>在macOS 10.12，标记指针布局已更改为还支持52位有效载荷和更多的标记索引：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tag indexes 0..&lt;7 have a 60-bit payload.</span></span><br><span class="line"><span class="comment">// Tag index 7 is reserved.</span></span><br><span class="line"><span class="comment">// Tag indexes 8..&lt;264 have a 52-bit payload.</span></span><br><span class="line"><span class="comment">// Tag index 264 is reserved.</span></span><br></pre></td></tr></table></figure>

<p>标记索引告诉您标记指针所表示的类：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"> </span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"> </span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用声明在objc-internal.h中的函数，检查指针是否为标记指针很简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((intptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> objc_tag_index_t </span><br><span class="line">_objc_getTaggedPointerTag(<span class="keyword">const</span> <span class="keyword">void</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t basicTag = ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    uintptr_t extTag =   ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_EXT_INDEX_SHIFT) &amp; _OBJC_TAG_EXT_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (objc_tag_index_t)(extTag + OBJC_TAG_First52BitPayload);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (objc_tag_index_t)basicTag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，这些函数是静态内联函数，没有对外开放，我们别无选择，只能在代码中复制以实现。</p>
<p>另一方面，获取给定标记所注册的类的函数是对外的，可以使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns the registered class for the given tag.</span></span><br><span class="line"><span class="comment"> Returns nil if the tag is valid but has no registered class.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> This function searches the exported function: _objc_getClassForTag(objc_tag_index_t tag)</span></span><br><span class="line"><span class="comment"> declared in https://opensource.apple.com/source/objc4/objc4-706/runtime/objc-internal.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class _objc_getClassForTag(objc_tag_index_t tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> _objc_getClassForTag_searched = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> Class (*_objc_getClassForTag_func)(objc_tag_index_t) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!_objc_getClassForTag_searched)</span><br><span class="line">    &#123;</span><br><span class="line">        _objc_getClassForTag_func = (Class(*)(objc_tag_index_t))dlsym(RTLD_DEFAULT, <span class="string">"_objc_getClassForTag"</span>);</span><br><span class="line">        _objc_getClassForTag_searched = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(_objc_getClassForTag_func == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"*** Could not find _objc_getClassForTag()!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(_objc_getClassForTag_func != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_getClassForTag_func(tag);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，很容易创建一个函数来检查指针是否是标记指针，从而是有效的Objective-C对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Test if a pointer is a tagged pointer</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param inPtr is the pointer to check</span></span><br><span class="line"><span class="comment"> @param outClass returns the registered class for the tagged pointer.</span></span><br><span class="line"><span class="comment"> @return true if the pointer is a tagged pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> IsObjcTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> *inPtr, Class *outClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> isTaggedPointer = _objc_isTaggedPointer(inPtr);</span><br><span class="line">    <span class="keyword">if</span>(outClass != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isTaggedPointer)</span><br><span class="line">        &#123;</span><br><span class="line">            objc_tag_index_t tagIndex = _objc_getTaggedPointerTag(inPtr);</span><br><span class="line">            *outClass = _objc_getClassForTag(tagIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *outClass = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> isTaggedPointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想了解更多关于标记指针你可以阅读下面2篇来自Mike Ash的文章：</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">Friday Q&amp;A 2013-09-27:ARM64 and You</a></p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Friday Q&amp;A 2012-07-27:Let’s Build Tagged Pointers</a></p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>有效指针必须与指针大小对齐。尝试在<a href="http://llvm.org/svn/llvm-project/lldb/trunk/examples/summaries/cocoa/objc_runtime.py" target="_blank" rel="noopener">objc_runtime.py</a>中的python函数<code>is_valid_pointer</code>中打印指针时，将在LLDB中进行此类检查：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def is_valid_pointer(pointer, pointer_size, allow_tagged=<span class="number">0</span>, allow_NULL=<span class="number">0</span>):</span><br><span class="line">    logger = lldb.formatters.Logger.Logger()</span><br><span class="line">    <span class="keyword">if</span> pointer is None:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> pointer == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> allow_NULL</span><br><span class="line">    <span class="keyword">if</span> allow_tagged and (pointer % <span class="number">2</span>) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ((pointer % pointer_size) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>最后的检查验证指针是否与指针大小对齐。我们可以实现相同的检查：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((uintptr_t)inPtr % <span class="keyword">sizeof</span>(uintptr_t)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位的使用"><a href="#位的使用" class="headerlink" title="位的使用"></a>位的使用</h3><p>LLDB源码在objc_runtime.py中还有一个有趣的函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># Objective-C runtime has a rule that pointers <span class="keyword">in</span> a class_t will only have bits <span class="number">0</span> thru <span class="number">46</span> set</span><br><span class="line"><span class="meta"># so <span class="meta-keyword">if</span> any pointer has bits 47 thru 63 high we know that this is not a</span></span><br><span class="line"><span class="meta"># valid isa</span></span><br><span class="line">@staticmethod</span><br><span class="line">def is_allowed_pointer(pointer):</span><br><span class="line">    logger = lldb.formatters.Logger.Logger()</span><br><span class="line">    <span class="keyword">if</span> pointer is None:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ((pointer &amp; <span class="number">0xFFFF800000000000</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>同样，我们可以轻松实现相同的检查：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(((uintptr_t)inPtr &amp; <span class="number">0xFFFF800000000000</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有效可读的内存"><a href="#有效可读的内存" class="headerlink" title="有效可读的内存"></a>有效可读的内存</h3><p>为了有效，指针应该指向有效可读的内存。我们可以用<code>vm_region_64()</code>来确保内存可读，<code>vm_read()</code>确保内存有效：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Test if the pointer points to readable and valid memory.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param inPtr is the pointer</span></span><br><span class="line"><span class="comment"> @return true if the pointer points to readable and valid memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> IsValidReadableMemory(<span class="keyword">const</span> <span class="keyword">void</span> *inPtr)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t error = KERN_SUCCESS;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Check for read permissions</span></span><br><span class="line">    <span class="keyword">bool</span> hasReadPermissions = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    vm_size_t vmsize;</span><br><span class="line">    vm_address_t address = (vm_address_t)inPtr;</span><br><span class="line">    vm_region_basic_info_data_t info;</span><br><span class="line">    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line"> </span><br><span class="line">    memory_object_name_t object;</span><br><span class="line"> </span><br><span class="line">    error = vm_region_64(mach_task_self(), &amp;address, &amp;vmsize, VM_REGION_BASIC_INFO, (vm_region_info_t)&amp;info, &amp;info_count, &amp;object);</span><br><span class="line">    <span class="keyword">if</span>(error != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// vm_region/vm_region_64 returned an error</span></span><br><span class="line">        hasReadPermissions = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hasReadPermissions = (info.protection &amp; VM_PROT_READ);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(!hasReadPermissions)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Read the memory</span></span><br><span class="line">    vm_offset_t readMem = <span class="number">0</span>;</span><br><span class="line">    mach_msg_type_number_t size = <span class="number">0</span>;</span><br><span class="line">    error = vm_read(mach_task_self(), (vm_address_t)inPtr, <span class="keyword">sizeof</span>(uintptr_t), &amp;readMem, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(error != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// vm_read returned an error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证isa指针并获取Class指针"><a href="#验证isa指针并获取Class指针" class="headerlink" title="验证isa指针并获取Class指针"></a>验证isa指针并获取Class指针</h3><p>现在我们知道当前地址指向有效可读的内存，我们可以提取可能的isa指针并获取Class指针。由Greg Parker在[[objc explain]:Non_pointer isa](<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)中记录到：" target="_blank" rel="noopener">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)中记录到：</a></p>
<blockquote>
<p><em>If you are writing a debugger-like tool, the Objective-C runtime exports some variables to help decode isa fields. objc_debug_isa_class_mask describes which bits are the class pointer: (isa &amp; class_mask) == class pointer. objc_debug_isa_magic_mask and objc_debug_isa_magic_value describe some bits that help distinguish valid isa fields from other invalid values: (isa &amp; magic_mask) == magic_value for isa fields that are not raw class pointers. These variables may change in the future so do not use them in application code.</em></p>
</blockquote>
<p>以下是验证isa指针并提取Class指针的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">uintptr_t isa = (*(uintptr_t *)inPtr);</span><br><span class="line">Class ptrClass = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((isa &amp; ~ISA_MASK) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ptrClass = (Class)isa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((isa &amp; ISA_MAGIC_MASK) == ISA_MAGIC_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrClass = (Class)(isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptrClass = (Class)isa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(ptrClass == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证Class是否存在"><a href="#验证Class是否存在" class="headerlink" title="验证Class是否存在"></a>验证Class是否存在</h3><p>现在我们获取到了Class，我们可以检查Objective-C运行时是否知道它：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isKnownClass = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> numClasses = <span class="number">0</span>;</span><br><span class="line">Class *classesList = objc_copyClassList(&amp;numClasses);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (classesList[i] == ptrClass)</span><br><span class="line">    &#123;</span><br><span class="line">        isKnownClass = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free(classesList);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!isKnownClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤掉一些误报"><a href="#过滤掉一些误报" class="headerlink" title="过滤掉一些误报"></a>过滤掉一些误报</h3><p>Greg Parker提供了一个<a href="https://twitter.com/gparker/status/801894068502433792" target="_blank" rel="noopener">好技巧</a>，通过检查指针分配的大小是否大于类实例的大小来过滤掉一些误报：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">size_t pointerSize = malloc_size(inPtr);</span><br><span class="line"><span class="keyword">if</span>(pointerSize &gt; <span class="number">0</span> &amp;&amp; pointerSize &lt; class_getInstanceSize(ptrClass))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在，我们拥有了用于构建一个函数的所有元素，该函数返回一个布尔值，该布尔值指示指针是否为Objective-C对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Test if a pointer is an Objective-C object</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param inPtr is the pointer to check</span></span><br><span class="line"><span class="comment"> @return true if the pointer is an Objective-C object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> IsObjcObject(<span class="keyword">const</span> <span class="keyword">void</span> *inPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NULL pointer is not an Objective-C object</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(inPtr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check for tagged pointers</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(IsObjcTaggedPointer(inPtr, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check if the pointer is aligned</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (((uintptr_t)inPtr % <span class="keyword">sizeof</span>(uintptr_t)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// From LLDB:</span></span><br><span class="line">    <span class="comment">// Objective-C runtime has a rule that pointers in a class_t will only have bits 0 thru 46 set</span></span><br><span class="line">    <span class="comment">// so if any pointer has bits 47 thru 63 high we know that this is not a valid isa</span></span><br><span class="line">    <span class="comment">// See http://llvm.org/svn/llvm-project/lldb/trunk/examples/summaries/cocoa/objc_runtime.py</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(((uintptr_t)inPtr &amp; <span class="number">0xFFFF800000000000</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check if the memory is valid and readable</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(!IsValidReadableMemory(inPtr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Get the Class from the pointer</span></span><br><span class="line">    <span class="comment">// From http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html :</span></span><br><span class="line">    <span class="comment">// If you are writing a debugger-like tool, the Objective-C runtime exports some variables</span></span><br><span class="line">    <span class="comment">// to help decode isa fields. objc_debug_isa_class_mask describes which bits are the class pointer:</span></span><br><span class="line">    <span class="comment">// (isa &amp; class_mask) == class pointer.</span></span><br><span class="line">    <span class="comment">// objc_debug_isa_magic_mask and objc_debug_isa_magic_value describe some bits that help</span></span><br><span class="line">    <span class="comment">// distinguish valid isa fields from other invalid values:</span></span><br><span class="line">    <span class="comment">// (isa &amp; magic_mask) == magic_value for isa fields that are not raw class pointers.</span></span><br><span class="line">    <span class="comment">// These variables may change in the future so do not use them in application code.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     </span><br><span class="line">    uintptr_t isa = (*(uintptr_t *)inPtr);</span><br><span class="line">    Class ptrClass = <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((isa &amp; ~ISA_MASK) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrClass = (Class)isa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((isa &amp; ISA_MAGIC_MASK) == ISA_MAGIC_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            ptrClass = (Class)(isa &amp; ISA_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptrClass = (Class)isa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(ptrClass == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Verifies that the found Class is a known class.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">bool</span> isKnownClass = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numClasses = <span class="number">0</span>;</span><br><span class="line">    Class *classesList = objc_copyClassList(&amp;numClasses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (classesList[i] == ptrClass)</span><br><span class="line">        &#123;</span><br><span class="line">            isKnownClass = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classesList);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(!isKnownClass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// From Greg Parker</span></span><br><span class="line">    <span class="comment">// https://twitter.com/gparker/status/801894068502433792</span></span><br><span class="line">    <span class="comment">// You can filter out some false positives by checking malloc_size(obj) &gt;= class_getInstanceSize(cls).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    size_t pointerSize = malloc_size(inPtr);</span><br><span class="line">    <span class="keyword">if</span>(pointerSize &gt; <span class="number">0</span> &amp;&amp; pointerSize &lt; class_getInstanceSize(ptrClass))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了测试此功能，我构建了一个简单的iOS应用来检查各种指针。这是在iOS 10.1.1（64位）上运行时的输出：</p>
<p><img src="https://i.loli.net/2019/12/18/xtROaqd3iEQ8jDh.png" alt="tests.png"></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/IsObjcObject.c" target="_blank" rel="noopener">IsObjcObject.c</a></p>
<p><a href="https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/IsObjcObject.zip" target="_blank" rel="noopener">Sources of the test app</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><a href="https://opensource.apple.com/source/objc4/objc4-706/" target="_blank" rel="noopener">objc4-706</a> from macOS 10.12</p>
</li>
<li><p><a href="https://lldb.llvm.org/resources/contributing.html" target="_blank" rel="noopener">LLDB git repository</a>(November 2016)</p>
</li>
<li><p><a href="https://www.cocoawithlove.com/2010/10/testing-if-arbitrary-pointer-is-valid.html" target="_blank" rel="noopener">Testing if an arbitrary pointer is valid object pointer</a> from Matt Gallagher</p>
</li>
<li><p><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">Friday Q&amp;A 2013-09-27:ARM64 and You</a> from Mike Ash</p>
</li>
<li><p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Friday Q&amp;A 2012-07-27:Let’s Build Tagged Pointers</a> from Mike Ash</p>
</li>
<li><p>[[objc explain]:Non_pointer isa](<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</a>) from Greg Parker</p>
</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>2016.11.24：根据Greg Parker的反馈进行了2处更改：</p>
<ul>
<li>过滤掉一些误报</li>
<li>使用<code>objc_copyClassList()</code>来代替<code>objc_getClassList()</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Aspects解读（一）</title>
    <url>/uncategorized/Aspects%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Aspects解读（一）"><a href="#Aspects解读（一）" class="headerlink" title="Aspects解读（一）"></a>Aspects解读（一）</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Aspects是一个基于runtime运行时实现的轻量级AOP编程库，整个库代码不足千行，但干货满满。</p>
<p>阅读本文前，希望你具备：</p>
<p>1.看过Block源码</p>
<p>2.了解过运行时</p>
<p>Aspects源码地址：<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Github</a>(版本：Aspects v1.4.2)</p>
<p>Block源码地址：<a href="https://opensource.apple.com/source/libclosure/libclosure-73/Block_private.h.auto.html" target="_blank" rel="noopener">libclosure-73/Block_private.h</a></p>
<p>runtime源码地址：<a href="https://opensource.apple.com/source/objc4/objc4-750" target="_blank" rel="noopener">objc4-750</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p>
<a id="more"></a>

<p>感谢以下文章以及苹果文档给予我阅读源码上的帮助(侵删)：</p>
<p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<p><a href="https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html" target="_blank" rel="noopener">do…while(0)的妙用</a></p>
<p><a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">Objective-C中的消息与消息转发</a></p>
<p><a href="https://www.jianshu.com/p/1849068b7833" target="_blank" rel="noopener">探究Block之MethodSignature</a></p>
<p><a href="https://juejin.im/post/5a459f6c51882538fe6316d5" target="_blank" rel="noopener">你真的会判断_objc_msgForward_stret吗</a></p>
<p>这篇笔记主要是记录阅读Aspects源码时遇到的知识点以及思路分析整理，如有错误望指正！</p>
<p>那我们开始吧，首先介绍库中部分函数实现的知识点。</p>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Aspects.h&quot;</span><br><span class="line">#import &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;message.h&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void aspect_performLocked(dispatch_block_t block) &#123;</span><br><span class="line">    static OSSpinLock aspect_lock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">    OSSpinLockLock(&amp;aspect_lock);</span><br><span class="line">    block();</span><br><span class="line">    OSSpinLockUnlock(&amp;aspect_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSAtomic.h 引入自旋锁OSSpinLock，通过函数<code>aspect_performLocked</code>以保证线程安全。然而OSSpinLock存在<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">优先级反转问题</a>，苹果已在 iOS10 设其为deprecated，部分开发者提issue改为<code>os_unfair_lock</code>，作者<a href="https://github.com/steipete/Aspects/issues/128" target="_blank" rel="noopener">没有采纳</a>。</p>
<p>###do{}while(0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define AspectLog(...)</span><br><span class="line">&#x2F;&#x2F;#define AspectLog(...) do &#123; NSLog(__VA_ARGS__); &#125;while(0)</span><br><span class="line">#define AspectLogError(...) do &#123; NSLog(__VA_ARGS__); &#125;while(0)</span><br></pre></td></tr></table></figure>

<p>需要注意<code>do{}while(0)</code>的使用，这种定义方式在Linux内核等代码中大量使用，主要是为了<a href="https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html]" target="_blank" rel="noopener">多行宏定义</a>的实现。</p>
<p>###AspectInfo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里定义了AspectInfo类，遵循Aspects.h头文件中声明的&lt;AspectInfo&gt;协议，主要保留了hook的对象以及原始函数实现，instance用<code>unsafe_unretained</code>修饰，即对需要hook的实例对象或类对象弱引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)arguments &#123;</span><br><span class="line">    if (!_arguments) &#123;</span><br><span class="line">        _arguments &#x3D; self.originalInvocation.aspects_arguments;</span><br><span class="line">    &#125;</span><br><span class="line">    return _arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arguments通过懒加载获取，组装成数组的过程比较昂贵。库中创建了NSInvocation的分类Aspects，新增了<code>aspects_arguments</code>和<code>aspect_argumentAtIndex:</code>2个实例方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation NSInvocation (Aspects)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Thanks to the ReactiveCocoa team for providing a generic solution for this.</span><br><span class="line">- (id)aspect_argumentAtIndex:(NSUInteger)index &#123;</span><br><span class="line">	const char *argType &#x3D; [self.methodSignature getArgumentTypeAtIndex:index];</span><br><span class="line">	&#x2F;&#x2F; Skip const type qualifier.</span><br><span class="line">	if (argType[0] &#x3D;&#x3D; _C_CONST) argType++;</span><br><span class="line"></span><br><span class="line">#define WRAP_AND_RETURN(type) do &#123; type val &#x3D; 0; [self getArgument:&amp;val atIndex:(NSInteger)index]; return @(val); &#125; while (0)</span><br><span class="line">	if (strcmp(argType, @encode(id)) &#x3D;&#x3D; 0 || strcmp(argType, @encode(Class)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		__autoreleasing id returnObj;</span><br><span class="line">		[self getArgument:&amp;returnObj atIndex:(NSInteger)index];</span><br><span class="line">		return returnObj;</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(SEL)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        SEL selector &#x3D; 0;</span><br><span class="line">        [self getArgument:&amp;selector atIndex:(NSInteger)index];</span><br><span class="line">        return NSStringFromSelector(selector);</span><br><span class="line">    &#125; else if (strcmp(argType, @encode(Class)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        __autoreleasing Class theClass &#x3D; Nil;</span><br><span class="line">        [self getArgument:&amp;theClass atIndex:(NSInteger)index];</span><br><span class="line">        return theClass;</span><br><span class="line">        &#x2F;&#x2F; Using this list will box the number with the appropriate constructor, instead of the generic NSValue.</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(char)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(char);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(int)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(int);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(short)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(short);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(long long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(long long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned char)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned char);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned int)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned int);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned short)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned short);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned long long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned long long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(float)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(float);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(double)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(double);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(BOOL)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(BOOL);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(bool)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(BOOL);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(char *)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(const char *);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(void (^)(void))) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		__unsafe_unretained id block &#x3D; nil;</span><br><span class="line">		[self getArgument:&amp;block atIndex:(NSInteger)index];</span><br><span class="line">		return [block copy];</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		NSUInteger valueSize &#x3D; 0;</span><br><span class="line">		NSGetSizeAndAlignment(argType, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">		unsigned char valueBytes[valueSize];</span><br><span class="line">		[self getArgument:valueBytes atIndex:(NSInteger)index];</span><br><span class="line"></span><br><span class="line">		return [NSValue valueWithBytes:valueBytes objCType:argType];</span><br><span class="line">	&#125;</span><br><span class="line">	return nil;</span><br><span class="line">#undef WRAP_AND_RETURN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)aspects_arguments &#123;</span><br><span class="line">	NSMutableArray *argumentsArray &#x3D; [NSMutableArray array];</span><br><span class="line">	for (NSUInteger idx &#x3D; 2; idx &lt; self.methodSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">		[argumentsArray addObject:[self aspect_argumentAtIndex:idx] ?: NSNull.null];</span><br><span class="line">	&#125;</span><br><span class="line">	return [argumentsArray copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>aspect_argumentAtIndex:</code>大体上通过C函数strcmp判断参数类型是否相等，来获取对应index的参数，在<code>aspects_arguments</code>中组装到argumentArray中并返回。这里作者感谢ReactiveCocoa团队提供的通用解决方案。</p>
<p>###AspectIdentifier</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks a single aspect.</span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectIdentifier持有hook相关的信息，注意这里object是用weak修饰，即对hook对象弱引用。让我们看看初始化方法<code>identifierWithSelector:object:options:block:error:</code>的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error &#123;</span><br><span class="line">    NSCParameterAssert(block);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line">    NSMethodSignature *blockSignature &#x3D; aspect_blockMethodSignature(block, error); &#x2F;&#x2F; TODO: check signature compatibility, etc.</span><br><span class="line">    if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AspectIdentifier *identifier &#x3D; nil;</span><br><span class="line">    if (blockSignature) &#123;</span><br><span class="line">        identifier &#x3D; [AspectIdentifier new];</span><br><span class="line">        identifier.selector &#x3D; selector;</span><br><span class="line">        identifier.block &#x3D; block;</span><br><span class="line">        identifier.blockSignature &#x3D; blockSignature;</span><br><span class="line">        identifier.options &#x3D; options;</span><br><span class="line">        identifier.object &#x3D; object; &#x2F;&#x2F; weak</span><br><span class="line">    &#125;</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aspect_blockMethodSignature</code>获取blockSignature，然后判断与原始函数实现的兼容性，初始化identifier以及其属性并返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout &#x3D; (__bridge void *)block;</span><br><span class="line">	if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	void *desc &#x3D; layout-&gt;descriptor;</span><br><span class="line">	desc +&#x3D; 2 * sizeof(unsigned long int);</span><br><span class="line">	if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">		desc +&#x3D; 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">	if (!desc) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	const char *signature &#x3D; (*(const char **)desc);</span><br><span class="line">	return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aspect_blockMethodSignature</code>主要步骤如下：</p>
<p>1.强转block为自定义的AspectBlockRef类型指针</p>
<p>2.通过与运算<code>layout-&gt;flags &amp; AspectBlockFlagsHasSignature</code>判断当前block是否包含签名</p>
<p>3.获取<code>layout-&gt;descriptor</code>的指针desc，指针地址加上 <code>2 * sizeof(unsigned long int)</code>，即reserved和size占用的内存地址大小</p>
<p>4.通过与运算<code>layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers</code>判断当前block是否拷贝到堆上，若成立，则desc指针地址再加上 <code>2 * sizeof(void *)</code>，即copy和dispose占用的内存地址大小</p>
<p>5.判断desc是否有值，通过<code>[NSMethodSignature signatureWithObjCTypes:]</code>返回签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Block internals.</span><br><span class="line">typedef NS_OPTIONS(int, AspectBlockFlags) &#123;</span><br><span class="line">	AspectBlockFlagsHasCopyDisposeHelpers &#x3D; (1 &lt;&lt; 25),</span><br><span class="line">	AspectBlockFlagsHasSignature          &#x3D; (1 &lt;&lt; 30)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你阅读过Block的<a href="https://opensource.apple.com/source/libclosure/libclosure-73/Block_private.h.auto.html" target="_blank" rel="noopener">源码</a>，可以发现这里的枚举跟<code>Block_layout-&gt;flags</code>中<code>BLOCK_HAS_COPY_DISPOSE</code>和<code>BLOCK_HAS_SIGNATURE</code>值相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _AspectBlock &#123;</span><br><span class="line">	__unused Class isa;</span><br><span class="line">	AspectBlockFlags flags;</span><br><span class="line">	__unused int reserved;</span><br><span class="line">	void (__unused *invoke)(struct _AspectBlock *block, ...);</span><br><span class="line">	struct &#123;</span><br><span class="line">		unsigned long int reserved;</span><br><span class="line">		unsigned long int size;</span><br><span class="line">		&#x2F;&#x2F; requires AspectBlockFlagsHasCopyDisposeHelpers</span><br><span class="line">		void (*copy)(void *dst, const void *src);</span><br><span class="line">		void (*dispose)(const void *);</span><br><span class="line">		&#x2F;&#x2F; requires AspectBlockFlagsHasSignature</span><br><span class="line">		const char *signature;</span><br><span class="line">		const char *layout;</span><br><span class="line">	&#125; *descriptor;</span><br><span class="line">	&#x2F;&#x2F; imported variables</span><br><span class="line">&#125; *AspectBlockRef;</span><br></pre></td></tr></table></figure>

<p>AspectBlockRef跟源码中Block的结构体Block_layout的定义也是一致的。<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes" target="_blank" rel="noopener">__unused</a>代表这个函数或者变量可能不使用，避免产生GCC编译器警告。</p>
<p>回到<code>identifierWithSelector:object:options:block:error:</code>方法中，接下来通过<code>aspect_isCompatibleBlockSignature</code>判断block参数与原始SEL参数的兼容性，不兼容则返回nil。然后给实例对象identifier各个属性赋值并返回identifier，AspectIdentifier的初始化方法到此结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(blockSignature);</span><br><span class="line">    NSCParameterAssert(object);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line"></span><br><span class="line">    BOOL signaturesMatch &#x3D; YES;</span><br><span class="line">    NSMethodSignature *methodSignature &#x3D; [[object class] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    if (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果block的参数数量大于原方法的参数数量，不匹配</span><br><span class="line">        signaturesMatch &#x3D; NO;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if (blockSignature.numberOfArguments &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果block的参数数量大于1，即有id&lt;AspectInfo&gt;，取出并对比&#39;@&#39;，不是一个对象类型，就不匹配</span><br><span class="line">            const char *blockType &#x3D; [blockSignature getArgumentTypeAtIndex:1];</span><br><span class="line">            if (blockType[0] !&#x3D; &#39;@&#39;) &#123;</span><br><span class="line">                signaturesMatch &#x3D; NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对于 method，参数0位是 self，参数1位是 SEL。对于 blockSignature，参数0位是 block，参数1位是 id&lt;AspectInfo&gt;。我们从参数2位开始做比较。</span><br><span class="line">        &#x2F;&#x2F; block 的参数数量可以少于 method，没事儿。</span><br><span class="line">        if (signaturesMatch) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果以上都符合，那么从第2位参数开始对比数据类型</span><br><span class="line">            for (NSUInteger idx &#x3D; 2; idx &lt; blockSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">                const char *methodType &#x3D; [methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                const char *blockType &#x3D; [blockSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                &#x2F;&#x2F; 不能是可选数据类型</span><br><span class="line">                if (!methodType || !blockType || methodType[0] !&#x3D; blockType[0]) &#123;</span><br><span class="line">                    signaturesMatch &#x3D; NO; break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!signaturesMatch) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;Block signature %@ doesn&#39;t match %@.&quot;, blockSignature, methodSignature];</span><br><span class="line">        AspectError(AspectErrorIncompatibleBlockSignature, description);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-(BOOL)invokeWithInfo:(id\&lt;AspectInfo&gt;)info</code>方法即调用hook的block代码。这里再次检查了一遍参数数量（其实没必要），并从2位开始，逐一把原函数中的参数赋给blockInvocation，最后invokeWithTarget调用block的函数实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    NSInvocation *blockInvocation &#x3D; [NSInvocation invocationWithMethodSignature:self.blockSignature];</span><br><span class="line">    NSInvocation *originalInvocation &#x3D; info.originalInvocation;</span><br><span class="line">    NSUInteger numberOfArguments &#x3D; self.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 谨慎起见，我们也要检查挂钩注册（参数数量）</span><br><span class="line">    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; blockInvocation 中的 &#39;self&#39; 实际将是 AspectInfo (可选)</span><br><span class="line">    if (numberOfArguments &gt; 1) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	void *argBuf &#x3D; NULL;</span><br><span class="line">    for (NSUInteger idx &#x3D; 2; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        const char *type &#x3D; [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">		NSUInteger argSize;</span><br><span class="line">		NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line">        </span><br><span class="line">		if (!(argBuf &#x3D; reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);</span><br><span class="line">			return NO;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [blockInvocation invokeWithTarget:self.block];</span><br><span class="line">    </span><br><span class="line">    if (argBuf !&#x3D; NULL) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，一般的方法调用在运行时是通过消息转发机制来完成，即<a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">[receiver message]</a>的形式，最终都转换成<code>objc_msgSend(receiver, @selector(message))</code>这样的纯C调用。但是，block并没有实际意义上的selector，运行时该如何调用block函数实现呢。没错，就是通过<code>[NSInvocation invocationWithMethodSignature:]</code>和<code>[NSInvocation invokeWithTarget:]</code>2个方法，获取到block的<a href="https://www.jianshu.com/p/1849068b7833" target="_blank" rel="noopener">signature</a>后，生成blockInvocation对象，再来调用block。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)remove &#123;</span><br><span class="line">    return aspect_remove(self, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循&lt;AspectToken&gt;协议实现了remove方法。</p>
<h3 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks all aspects for an object&#x2F;class.</span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectsContainer是AspectIdentifier的容器。主要是存储一个对象或者一个类的所有Aspects hook代码。可以注意到这里用到了atomic原子性修饰3个AspectsArray（方法执行前/替换方法实现/方法执行后），保证3个Array的set、get方法读写安全。接下来我们看看AspectsContainer具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AspectsContainer</span><br><span class="line"></span><br><span class="line">- (BOOL)hasAspects &#123;</span><br><span class="line">    return self.beforeAspects.count &gt; 0 || self.insteadAspects.count &gt; 0 || self.afterAspects.count &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123;</span><br><span class="line">    NSParameterAssert(aspect);</span><br><span class="line">    NSUInteger position &#x3D; options&amp;AspectPositionFilter;</span><br><span class="line">    switch (position) &#123;</span><br><span class="line">        case AspectPositionBefore:  self.beforeAspects  &#x3D; [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">        case AspectPositionInstead: self.insteadAspects &#x3D; [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">        case AspectPositionAfter:   self.afterAspects   &#x3D; [(self.afterAspects  ?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)removeAspect:(id)aspect &#123;</span><br><span class="line">    for (NSString *aspectArrayName in @[NSStringFromSelector(@selector(beforeAspects)),</span><br><span class="line">                                        NSStringFromSelector(@selector(insteadAspects)),</span><br><span class="line">                                        NSStringFromSelector(@selector(afterAspects))]) &#123;</span><br><span class="line">        NSArray *array &#x3D; [self valueForKey:aspectArrayName];</span><br><span class="line">        NSUInteger index &#x3D; [array indexOfObjectIdenticalTo:aspect];</span><br><span class="line">        if (array &amp;&amp; index !&#x3D; NSNotFound) &#123;</span><br><span class="line">            NSMutableArray *newArray &#x3D; [NSMutableArray arrayWithArray:array];</span><br><span class="line">            [newArray removeObjectAtIndex:index];</span><br><span class="line">            [self setValue:newArray forKey:aspectArrayName];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, before:%@, instead:%@, after:%@&gt;&quot;, self.class, self, self.beforeAspects, self.insteadAspects, self.afterAspects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>hasAspects返回当前对象或者类对象是否有Aspects hook代码。</p>
<p>在<code>addAspects:withOptions:</code>实现中，通过与运算获取AspectOptions，set方法保证读写安全赋值给对应的AspectsArray。</p>
<p>在<code>removeAspect:</code>实现中，遍历3个array，KVC获取与设置array的值。用到了<a href="https://developer.apple.com/documentation/foundation/nsarray/1410847-indexofobjectidenticalto?language=objc" target="_blank" rel="noopener">indexOfObjectIdenticalTo:</a>快速获取aspect所在索引。相对于<code>indexOfObject:</code>，<code>indexOfObjectIdenticalTo:</code><a href="https://stackoverflow.com/questions/3167849/indexofobject-vs-indexofobjectidenticalto" target="_blank" rel="noopener">更快</a>(直接比较地址，而indexOfObject有个isEqual的过程)。</p>
<p>这里有个疑问，既然用atomic保证原子性，<code>addAspects:withOptions:</code>通过set方法保证了读写安全，<code>removeAspect:</code>中则用到了KVC来获取与重新赋值array，为什么不继续使用set、get方法来保证读写安全呢？</p>
<p>###AspectTracker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface AspectTracker : NSObject</span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass;</span><br><span class="line">@property (nonatomic, strong) Class trackedClass;</span><br><span class="line">@property (nonatomic, readonly) NSString *trackedClassName;</span><br><span class="line">@property (nonatomic, strong) NSMutableSet *selectorNames;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;</span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectTracker顾名思义是切面追踪器。主要功能是为了判断当前类对象是否可以被hook，并对允许hook的类添加追踪器以便再次判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123;</span><br><span class="line">    static NSMutableDictionary *swizzledClassesDict;</span><br><span class="line">    static dispatch_once_t pred;</span><br><span class="line">    dispatch_once(&amp;pred, ^&#123;</span><br><span class="line">        swizzledClassesDict &#x3D; [NSMutableDictionary new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return swizzledClassesDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追踪器存储在静态变量swizzledClassesDict中，通过dispatch_once创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AspectTracker</span><br><span class="line"></span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        _trackedClass &#x3D; trackedClass;</span><br><span class="line">        _selectorNames &#x3D; [NSMutableSet new];</span><br><span class="line">        _selectorNamesToSubclassTrackers &#x3D; [NSMutableDictionary new];&#x2F;&#x2F; &lt;NSString: NSMutableSet&lt;AspectTracker&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    return self.selectorNamesToSubclassTrackers[selectorName] !&#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *trackerSet &#x3D; self.selectorNamesToSubclassTrackers[selectorName];</span><br><span class="line">    if (!trackerSet) &#123;</span><br><span class="line">        trackerSet &#x3D; [NSMutableSet new];</span><br><span class="line">        self.selectorNamesToSubclassTrackers[selectorName] &#x3D; trackerSet;</span><br><span class="line">    &#125;</span><br><span class="line">    [trackerSet addObject:subclassTracker];</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *trackerSet &#x3D; self.selectorNamesToSubclassTrackers[selectorName];</span><br><span class="line">    [trackerSet removeObject:subclassTracker];</span><br><span class="line">    if (trackerSet.count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        [self.selectorNamesToSubclassTrackers removeObjectForKey:selectorName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *hookingSubclassTrackers &#x3D; [NSMutableSet new];</span><br><span class="line">    &#x2F;&#x2F;递归获取所有当前类的子类相对于该SEL的跟踪器，若tracker.selectorNames包含该SEL name，则添加到hookingSubclassTrackers集合中</span><br><span class="line">    for (AspectTracker *tracker in self.selectorNamesToSubclassTrackers[selectorName]) &#123;</span><br><span class="line">        if ([tracker.selectorNames containsObject:selectorName]) &#123;</span><br><span class="line">            [hookingSubclassTrackers addObject:tracker];</span><br><span class="line">        &#125;</span><br><span class="line">        [hookingSubclassTrackers unionSet:[tracker subclassTrackersHookingSelectorName:selectorName]];</span><br><span class="line">    &#125;</span><br><span class="line">    return hookingSubclassTrackers;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)trackedClassName &#123;</span><br><span class="line">    return NSStringFromClass(self.trackedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %@, trackedClass: %@, selectorNames:%@, subclass selector names: %@&gt;&quot;, self.class, self, NSStringFromClass(self.trackedClass), self.selectorNames, self.selectorNamesToSubclassTrackers.allKeys];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>initWithTrackedClass:</code>传入类初始化AspectTracker，<code>_trackedClass</code>为当前跟踪的类，用于trackedClassName方法返回类名；<code>_selectorNames</code>存储在当前类hook的selectorName； <code>_selectorNamesToSubclassTrackers</code>结构为<code>&lt;NSString: NSMutableSet&lt;AspectTracker&gt;&gt;</code>，即key为selectorName，value为<code>NSMutableSet&lt;AspectTracker&gt;</code>(所有子类对该SEL的追踪器)的可变字典。</p>
<p><code>subclassHasHookedSelectorName:</code>判断当前SEL是否在子类被Hook。</p>
<p><code>addSubclassTracker:hookingSelectorName:</code>添加子类SEL追踪器到字典selectorNamesToSubclassTrackers。</p>
<p><code>removeSubclassTracker:hookingSelectorName:</code>删除子类SEL追踪器。若追踪器set集合count为0，从字典selectorNamesToSubclassTrackers删除key(selectorName)对应NSMutableSet。</p>
<p><code>subclassTrackersHookingSelectorName</code>用来获取当前SEL的所有源追踪器，也就是说获取当前SEL在哪些子类被hook。</p>
<p>追踪器的实现比较绕，分为2种：</p>
<p>1.在当前类被hook的话，添加到selectorNames中；</p>
<p>2.在当前类的子类被hook的话，添加到selectorNamesToSubclassTrackers中。</p>
<p>以下是AspectTracker追踪器在<code>aspect_isSelectorAllowedAndTrack</code>方法中的实现流程图，建议结合代码理解。</p>
<p><img src="https://i.loli.net/2019/12/23/a5dH6kqmGEXi8b4.png" alt="Aspects-AspectTracker实现原理.jpg"></p>
<p>###aspect_isMsgForwardIMP和aspect_getMsgForwardIMP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BOOL aspect_isMsgForwardIMP(IMP impl) &#123;</span><br><span class="line">    return impl &#x3D;&#x3D; _objc_msgForward</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line">    || impl &#x3D;&#x3D; (IMP)_objc_msgForward_stret</span><br><span class="line">#endif</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) &#123;</span><br><span class="line">    IMP msgForwardIMP &#x3D; _objc_msgForward;</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line">    &#x2F;&#x2F; As an ugly internal runtime implementation detail in the 32bit runtime, we need to determine of the method we hook returns a struct or anything larger than id.</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;mac&#x2F;documentation&#x2F;DeveloperTools&#x2F;Conceptual&#x2F;LowLevelABI&#x2F;000-Introduction&#x2F;introduction.html</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ReactiveCocoa&#x2F;ReactiveCocoa&#x2F;issues&#x2F;783</span><br><span class="line">    &#x2F;&#x2F; http:&#x2F;&#x2F;infocenter.arm.com&#x2F;help&#x2F;topic&#x2F;com.arm.doc.ihi0042e&#x2F;IHI0042E_aapcs.pdf (Section 5.4)</span><br><span class="line">    Method method &#x3D; class_getInstanceMethod(self.class, selector);</span><br><span class="line">    const char *encoding &#x3D; method_getTypeEncoding(method);</span><br><span class="line">    BOOL methodReturnsStructValue &#x3D; encoding[0] &#x3D;&#x3D; _C_STRUCT_B;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            NSUInteger valueSize &#x3D; 0;</span><br><span class="line">            NSGetSizeAndAlignment(encoding, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">            if (valueSize &#x3D;&#x3D; 1 || valueSize &#x3D;&#x3D; 2 || valueSize &#x3D;&#x3D; 4 || valueSize &#x3D;&#x3D; 8) &#123;</span><br><span class="line">                methodReturnsStructValue &#x3D; NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @catch (__unused NSException *e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        msgForwardIMP &#x3D; (IMP)_objc_msgForward_stret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return msgForwardIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aspects中，arm64CPU架构下只用_objc_msgForward，建议看这篇<a href="https://juejin.im/post/5a459f6c51882538fe6316d5" target="_blank" rel="noopener">文章</a>理解。这2个函数实现主要在<code>aspect_prepareClassAndHookSelector</code>中用到，通过将selector对应IMP替换成 _objc_msgForward或者 _objc_msgForward_stret，可以触发消息转发，从而进入forwardInvocation的实现。</p>
<h3 id="aspect-invoke"><a href="#aspect-invoke" class="headerlink" title="aspect_invoke"></a>aspect_invoke</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define aspect_invoke(aspects, info) \</span><br><span class="line">for (AspectIdentifier *aspect in aspects) &#123;\</span><br><span class="line">    [aspect invokeWithInfo:info];\</span><br><span class="line">    if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span><br><span class="line">        aspectsToRemove &#x3D; [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者为了调试方便，把调用hook代码的过程替换成一个多行的宏定义。</p>
<p>接下来的部分将涉及到aspect_hookClass等的实现原理，由于篇幅过长，下一篇再进行分析。</p>
<p>这里是3篇比较好的文章：</p>
<p><a href="http://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">面向切面编程之 Aspects 源码解析及应用</a></p>
<p><a href="[https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%E4%B8%8EAspects%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md](https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/消息转发机制与Aspects源码解析.md)">消息转发机制与Aspects源码解析</a></p>
<p><a href="https://halfrost.com/ios_aspect/" target="_blank" rel="noopener">iOS如何实现 Aspect Oriented Programming</a></p>
<p>另：流程图、思维导图用<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>在线作图。</p>
]]></content>
  </entry>
</search>
