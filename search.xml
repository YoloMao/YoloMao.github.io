<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS SDK 开发中注意事项-学习总结</title>
    <url>/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/iOS%20SDK%20%E5%BC%80%E5%8F%91%E4%B8%AD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>1.确定代码规范、命名规范（包括资源文件）、注释规范；接口设计合理，多参数改成以对象的形式传入，参数合法性校验</p>
<p>2.防止符号重复，用加前缀的方式；如果必须用到三方库中的实现（如数据库），则抽取出需要的实现代码并加上前缀</p>
<a id="more"></a>

<p>3.发版本前需要对不同系统版本、不同机型进行测试</p>
<p>4.兼容旧版本（数据库兼容、API 兼容）</p>
<p>5.写好接入文档，提供 Demo；对常见使用问题做记录，遇到问题及时解决；写好版本更新说明</p>
<p>6.异常接入如参数错误、配置错误，通过打印日志提醒接入方；是否需要提供接入方开启 SDK Debug 日志入口？</p>
<p>7.兼容其他市面上的 SDK，避免出现异常情况</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>1.HTTPS 请求数据防篡改，是否可以明文传输（模仿 SSL 协议，非对称加密 + 对称加密 + hash）</p>
<p>2.本地缓存内容防篡改、防获取（加密）</p>
<p>3.重要代码混淆加固</p>
<p>4.反逆向（是否需要检测当前是越狱环境？）</p>
<h3 id="无感"><a href="#无感" class="headerlink" title="无感"></a>无感</h3><p>1.对使用内存的影响（防止出现内存泄漏的情况，降低内存峰值，提高内存利用率，处理内存警告；内存中的缓存数据设置上限大小）</p>
<p>2.对硬盘内存的影响（缓存数据设置上限大小、过期时间等，定制清理策略）</p>
<p>3.对CPU/主线程的影响</p>
<p>(1)使用多线程的方式调用，控制好并发</p>
<p>(2)一般 SDK 创建一个固定的线程，任务调度都丢到这个线程处理，处理完成后异步回到主线程更新</p>
<p>4.对耗电量的影响（网络请求、磁盘 IO、蓝牙、定位）</p>
<p>对于网络请求和磁盘 IO：</p>
<p>(1)减少、压缩网络数据，不要频繁地进行网络请求，尽量合并请求，预请求，让设备尽早进入闲置模式降低功耗；</p>
<p>(2)设置合适的请求超时时间，重连次数，在网络异常情况下取消请求；</p>
<p>(3)避免轮询请求；</p>
<p>(4)减少小数据磁盘 IO 次数，先放在内存中，再选择合适的时机写入磁盘；</p>
<p>5.对应用包大小的影响（善用设计模式，不要有重复代码，减小代码量；如果有资源文件，压缩）</p>
<h3 id="定制化、插件化"><a href="#定制化、插件化" class="headerlink" title="定制化、插件化"></a>定制化、插件化</h3><p>合理的架构设计实现可插拔</p>
<p>…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><em>[1]<a href="https://blog.bihe0832.com/sdk_summary.html" target="_blank" rel="noopener">SDK那些事（总纲）</a></em></p>
</li>
<li><p><em>[2]<a href="https://zhuanlan.zhihu.com/p/135315672" target="_blank" rel="noopener">iOS SDK开发二三事</a></em></p>
</li>
<li><p><em>[3]<a href="https://segmentfault.com/a/1190000004509668" target="_blank" rel="noopener">移动网络下的性能优化之省点篇</a></em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>从汇编看 lazy 符号绑定</title>
    <url>/iOS%E5%9F%BA%E7%A1%80/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9C%8B%20lazy%20%E7%AC%A6%E5%8F%B7%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>在 Mach-O 中，如果<code>__TEXT,__text</code> 用到了外部符号，比如 NSLog、objc_retain、printf 等等，其实是以 PIC 的方式调用。让我们利用 MachOView 从汇编层面看一下。</p>
<a id="more"></a>

<p>如下是 main 函数的汇编代码：</p>
<p><img src="https://i.loli.net/2021/04/13/6BsCE5FubSvXMqw.png" alt="image.png"></p>
<p>可以看到<code>objc_retainAutoreleasedReturnValue</code>的调用是通过 bl 指令跳转到<code>0x100c5a410</code>，我们通过在 lldb 中输入<code>image list</code>获取当前执行文件的基地址。</p>
<p><img src="https://i.loli.net/2021/04/13/dNzpJHA7VPbftmY.png" alt="image2.png"></p>
<p>得出在可执行文件中的偏移为<code>0x100c5a410 - 0x0000000100c54000 = 0x6410</code>。</p>
<p>打开 MachOView 加载可执行文件，找到 Offset 为<code>0x6410</code>的位置（在<code>__TEXT,__stubs</code>中）。</p>
<p><img src="https://i.loli.net/2021/04/13/HyTIUr57oSxQEiK.png" alt="image3.png"></p>
<p>机器码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1F2003D5</span><br><span class="line">70E20258</span><br><span class="line">00021FD6</span><br></pre></td></tr></table></figure>

<p>安装 radare2，通过以下方式可以方便完成汇编/机器码的转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rasm2 -a arm -b 64 -d fd031daa</span><br><span class="line">$ rasm2 -a arm -b 64 &#39;MOV x29, x29&#39;</span><br></pre></td></tr></table></figure>

<p>转换以上机器码可得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nop               &#x2F;&#x2F;无操作</span><br><span class="line">ldr x16, 0x5c4c   &#x2F;&#x2F;将当前 PC 指向地址 + 0x5c4c，存储在寄存器 x16 中</span><br><span class="line">br x16            &#x2F;&#x2F;跳转到寄存器 x16 所指向的地址</span><br></pre></td></tr></table></figure>

<p>可执行文件的基地址为<code>0x100000000</code> ，因此 x16 寄存器的值为<code>0x100000000 + 0x6410 + 0x4(第二条指令) + 0x5c4c = 0x10000c060</code>。</p>
<p>找到 Offset 为<code>0xc060</code>的位置，可以看到是在<code>la_symbol_ptr</code>中。</p>
<p><img src="https://i.loli.net/2021/04/13/bCkBxDTqPj3UZJa.png" alt="image4.png"></p>
<p>读取指针值为<code>0x1000064c4</code>，继续查找这个位置。</p>
<p><img src="https://i.loli.net/2021/04/14/3melAirT1USwkpu.png" alt="image5.png"></p>
<p>发现在<code>__TEXT,__stub_helper</code>中，这里的实现为 2 条汇编指令（这里 MachOView 帮我们将具体的地址计算出来了）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldr w16, #0x1000064cc &#x2F;&#x2F;ldr w16, 8，将 0x1000064cc 地址值的低地址 32 位存储在 w16 寄存器中</span><br><span class="line">b #0x100006428        &#x2F;&#x2F;b 0xffffffffffffff60，跳转到 0x100006428</span><br><span class="line">0x1f, 0x01, 0x00, 0x00</span><br></pre></td></tr></table></figure>

<p>找到<code>0x100006428</code>，其实就是<code>__TEXT,__stub_helper</code>第一行位置。</p>
<p><img src="https://i.loli.net/2021/04/13/ZxpMO8m74zvhYWd.png" alt="image6.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adr x17, #0x10000d4e0       &#x2F;&#x2F;adr x17, 0x70b8，将当前 PC 指向地址 + 0x70b8，存储在寄存器 x17 中</span><br><span class="line">nop                         &#x2F;&#x2F;无操作</span><br><span class="line">stp x16, x17, [sp, #-0x10]! &#x2F;&#x2F;依次将寄存器 x16、x17 的值存储在 SP - 0x10 和 SP - 0x8，然后将 SP 向低地址扩展 0x10</span><br><span class="line">nop                         &#x2F;&#x2F;无操作</span><br><span class="line">ldr x16, #0x100008000       &#x2F;&#x2F;ldr x16, 0x1bc8，将当前 PC 指向地址 + 0x1bc8，存储在寄存器 x16 中</span><br><span class="line">br x16                      &#x2F;&#x2F;跳转到寄存器 x16 所指向的地址</span><br></pre></td></tr></table></figure>

<p>查看对应地址：</p>
<p><img src="https://i.loli.net/2021/04/13/ob2vzCEAh4VXSLq.png" alt="image7.png"></p>
<p><img src="https://i.loli.net/2021/04/13/J4H7eCTyWFZcKd3.png" alt="image8.png"></p>
<p><code>0x10000d4e0</code> 是<code>__DATA,__data</code>的首地址；<code>0x100008000</code>是<code>dyld_stub_binder</code>函数的指针地址。</p>
<p>在<code>dyld_stub_binder</code>实现中，x16 寄存器中的值其实是作为<code>lazyBindingInfoOffset</code>传递到了<code>fastBindLazySymbol</code>函数。然后<code>fastBindLazySymbol</code>通过这个偏移值找到 <strong>Lazy Binding Info</strong> 中对应的绑定信息，获取到符号相对于<strong><code>__DATA,__la_symbol_str</code></strong>首地址的 offset。</p>
<p>当前 x16 寄存器的值为<code>0x11f</code>，加上 Lazy Binding Info 的首地址<code>0x1000102E8</code>，得出<code>0x100010407</code>。</p>
<p><img src="https://i.loli.net/2021/04/14/YMHztPraX8c91d4.png" alt="image9.png"></p>
<p>这里符号对应的 offset 需要通过 uleb128 转换（一个字节中 8 Bit，只有 7 Bit 用以存储内容，高位的 1 Bit 等于 1 时代表还有要往后取一个字节，等于 0 时以当前字节为结束），经过转换<code>0x60</code>还是<code>0x60</code>。</p>
<p>加上<strong><code>__DATA,__la_symbol_str</code></strong>首地址<code>0x10000C000</code>即为<code>0x10000c060</code>，与上文中获取到的地址相符。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态库中的 Lazy symbol Pointers 在代码中的体现是以桩代码（stub）的形式，当首次调用桩代码时：</p>
<p>1.汇编跳转到<code>la_symbol_ptr</code>表中获取到函数地址；</p>
<p>2.函数地址在<code>stub_helper</code>表中，调起<code>dyld_stub_binder</code>函数；</p>
<p>3.<code>dyld_stub_binder</code>调用<code>fastBindLazySymbol</code>来绑定符号，查找过程是通过<code>lazyBindingInfoOffset</code>值得到符号信息在 Dynamic Loader Info 中的 <strong>Lazy Binding Info</strong> 的偏移，通过 偏移值，查找到当前符号在<code>la_symbol_ptr</code>中的偏移值，然后就可以绑定函数符号正确的动态库函数地址了。</p>
<p>当第二次以及之后调用桩代码时，跳转到<code>la_symbol_ptr</code>表中获取到的函数地址即修改后的地址了。</p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
  </entry>
  <entry>
    <title>AutoreleasePool与编译器优化</title>
    <url>/iOS%E5%9F%BA%E7%A1%80/AutoreleasePool%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>某次偶然发现<code>main.m</code>里的 main 函数有所变化，经过一番查询<a href="#1"><sup>[1]</sup></a>，发现是从 Xcode 11 开始。</p>
<img src="https://i.loli.net/2021/04/07/xNm2AnloGjkSJrU.png" alt="mainInXcode.png" style="zoom:40%;" />

<p>而在此之前， main 函数的实现为：</p>
<img src="https://i.loli.net/2021/04/07/tzUpfadbuZGkPK6.png" alt="mainBeforeXcode11.png" style="zoom:40%;" />

<a id="more"></a>

<p>熟悉 AutoreleasePool 底层原理的同学应该都知道，在<code>@autoreleasepool</code>作用范围内生成的对象，在 ARC 的作用下，将加入自动释放池。如 Xcode 11 之前的 main 函数，结合汇编代码，实际内存管理将大概会展开为以下实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">  NSString *name &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">  name &#x3D; objc_autoreleaseReturnValue(name); &#x2F;&#x2F;objc_autorelease(name); </span><br><span class="line">  name &#x3D; objc_retainAutoreleasedReturnValue(name); &#x2F;&#x2F;objc_retain(name);</span><br><span class="line">  int tmp &#x3D; UIApplicationMain(argc, argv, nil, name);</span><br><span class="line">  objc_release(name);</span><br><span class="line">  objc_autoreleasePoolPop(pool); &#x2F;&#x2F;对 push 和 pop 之间加入自动释放池的对象进行 release 操作，即 [name release];</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际上：</p>
<ol>
<li><p><code>UIApplicationMain</code>函数在程序运行期间不会返回，因此这里生成的 name 对象一直会处在堆上无法释放造成内存泄漏；</p>
</li>
<li><p>并且程序终止之后，所使用的的内存空间将会由系统回收，自动释放池的 drain 在这里没有意义。</p>
</li>
</ol>
<p>新的模板代码中，将 name 对象的初始化操作与<code>UIApplicationMain</code>分离开，展开后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  NSString *name;</span><br><span class="line">  void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">  name &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">  name &#x3D; objc_autoreleaseReturnValue(name); &#x2F;&#x2F;objc_autorelease(name);</span><br><span class="line">  name &#x3D; objc_retainAutoreleasedReturnValue(name); &#x2F;&#x2F;objc_retain(name);</span><br><span class="line">  objc_release(nil); &#x2F;&#x2F;在汇编中，寄存器 r0 的值为 0x0，所以我也不知道这一步有什么用</span><br><span class="line">  objc_autoreleasePoolPop(pool); &#x2F;&#x2F;对自动释放池内所有对象进行 release 操作，即 [name release];</span><br><span class="line">  int tmp &#x3D; UIApplicationMain(argc, argv, nil, name);</span><br><span class="line">  objc_storeStrong(&amp;name, nil);</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>name 对象还是得不到释放，程序在终止前不会执行到<code>objc_storeStrong(&amp;name, nil);</code>。</p>
<p>那么修改的意义何在呢？</p>
<blockquote>
<p><em>// Setup code that might create autoreleased objects goes here.</em></p>
</blockquote>
<p>如果需要创建自动释放的对象，那么现在，在<code>@autoreleasepool</code>作用域内创建即可正常释放。</p>
<p>注意：以上伪代码中，<code>objc_autoreleaseReturnValue(name)</code> 其实是在 <code>NSStringFromClass([AppDelegate class])</code>中，这里将它提取出来方便理解。</p>
<h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>其实在上文的伪实现中，<code>objc_autoreleaseReturnValue(name)</code>和<code>objc_retainAutoreleasedReturnValue(name)</code>可以去掉，这一切都归功于 AutoreleasePool 与线程局部存储（Thread Local Storage, TLS）<a href="#2"><sup>[2]</sup></a>的配合。</p>
<p>在 arm64 架构下，<code>objc_autoreleaseReturnValue</code>执行时，会通过<code>__builtin_return_address(0)</code>判断当前函数返回地址对应的汇编指令，是否是<code>mov fp, fp</code>，如果是的话，将 0x1 作为 value，<code>RETURN_DISPOSITION_KEY</code> 作为 key，存储在 TLS 中，并直接返回 obj，不执行<code>objc_autorelease(obj)</code>；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; NSObject.mm</span><br><span class="line">&#x2F;&#x2F; Prepare a value at +1 for return through a +0 autoreleasing convention.</span><br><span class="line">id </span><br><span class="line">objc_autoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_autorelease(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; objc-object.h</span><br><span class="line">enum ReturnDisposition : bool &#123;</span><br><span class="line">    ReturnAtPlus0 &#x3D; false, ReturnAtPlus1 &#x3D; true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Try to prepare for optimized return with the given disposition (+0 or +1).</span><br><span class="line">&#x2F;&#x2F; Returns true if the optimized path is successful.</span><br><span class="line">&#x2F;&#x2F; Otherwise the return value must be retained and&#x2F;or autoreleased as usual.</span><br><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">prepareOptimizedReturn(ReturnDisposition disposition)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(getReturnDisposition() &#x3D;&#x3D; ReturnAtPlus0);</span><br><span class="line"></span><br><span class="line">    if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) &#123;</span><br><span class="line">        if (disposition) setReturnDisposition(disposition);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;arm64</span><br><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">callerAcceptsOptimizedReturn(const void *ra)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; fd 03 1d aa    mov fp, fp</span><br><span class="line">    &#x2F;&#x2F; arm64 instructions are well-aligned</span><br><span class="line">    if (*(uint32_t *)ra &#x3D;&#x3D; 0xaa1d03fd) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_retainAutoreleasedReturnValue</code>执行时，判断<code>RETURN_DISPOSITION_KEY</code> 对应 value 是否为 0x1 并重置为 0x0，是的话，则直接返回 obj，不执行<code>objc_retain(obj)</code>；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; NSObject.mm</span><br><span class="line">&#x2F;&#x2F; Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id</span><br><span class="line">objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (acceptOptimizedReturn() &#x3D;&#x3D; ReturnAtPlus1) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_retain(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; objc-object.h</span><br><span class="line">&#x2F;&#x2F; Try to accept an optimized return.</span><br><span class="line">&#x2F;&#x2F; Returns the disposition of the returned object (+0 or +1).</span><br><span class="line">&#x2F;&#x2F; An un-optimized return is +0.</span><br><span class="line">static ALWAYS_INLINE ReturnDisposition </span><br><span class="line">acceptOptimizedReturn()</span><br><span class="line">&#123;</span><br><span class="line">    ReturnDisposition disposition &#x3D; getReturnDisposition();</span><br><span class="line">    setReturnDisposition(ReturnAtPlus0);  &#x2F;&#x2F; reset to the unoptimized state</span><br><span class="line">    return disposition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上优化，一般情况下，由工厂方法生成的对象不再需要进入自动释放池，加快了释放过程。</p>
<p>另外，<code>mov fp, fp</code>是编译器对于<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleasedReturnValue</code>连续调用所做的一个标记<a href="#3"><sup>[3]</sup></a>。</p>
<blockquote>
<p><em>Well take a look at that. It’s added in a <code>mov r7, r7</code> in each case which is a noop (i.e. does nothing as it moves <code>r7</code> back into itself). If you examine the binary values for these instructions then you’ll see they match the values that we were told to compare against. The compiler has added this as a marker to tell the <code>objc_autoreleaseReturnValue</code> that the caller is about to call <code>objc_retainAutoreleasedReturnValue</code>.</em></p>
</blockquote>
<p>按照以上分析，新的 main 函数模板代码中，appDelegateClassName 不会进入自动释放池，而事实上确实如此，执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">&#x2F;&#x2F;    __weak NSString *a;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; Setup code that might create autoreleased objects goes here.</span><br><span class="line">        appDelegateClassName &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lldb 打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[32590]: ##############</span><br><span class="line">objc[32590]: AUTORELEASE POOLS for thread 0x102493880</span><br><span class="line">objc[32590]: 0 releases pending.</span><br><span class="line">objc[32590]: [0x1]  ................  PAGE (placeholder)</span><br><span class="line">objc[32590]: [0x1]  ################  POOL (placeholder)</span><br><span class="line">objc[32590]: ##############</span><br></pre></td></tr></table></figure>

<p>可以看到池中没有对象。</p>
<p>细心的同学可能会注意到，以上代码中有个<code>__weak</code>修饰的 a 变量，当我们把它也加入运行代码中时，lldb 打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[32676]: ##############</span><br><span class="line">objc[32676]: AUTORELEASE POOLS for thread 0x1025ab880</span><br><span class="line">objc[32676]: 2 releases pending.</span><br><span class="line">objc[32676]: [0x14c811000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[32676]: [0x14c811038]  ################  POOL 0x14c811038</span><br><span class="line">objc[32676]: [0x14c811040]       0x283f9c3e0  __NSCFString</span><br><span class="line">objc[32676]: ##############</span><br></pre></td></tr></table></figure>

<p>黑魔法失灵了！</p>
<h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>既然 AutoreleasePool 依据汇编层面进行了优化，那么我们便从汇编中一探究竟。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;没有加__weak： </span><br><span class="line">0x100072148 &lt;+72&gt;:  bl 0x100072478 ; symbol stub for: NSStringFromClass</span><br><span class="line">0x10007214c &lt;+76&gt;:  mov x29, x29 &#x2F;&#x2F;mov fp, fp</span><br><span class="line">0x100072150 &lt;+80&gt;:  bl 0x1000724e4 ; symbol stub for: objc_retainAutoreleasedReturnValue</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;加了__weak：</span><br><span class="line">0x1001da0b8 &lt;+76&gt;:  bl 0x1001da418 ; symbol stub for: NSStringFromClass</span><br><span class="line">0x1001da0bc &lt;+80&gt;:  str x0, [sp, #0x8] &#x2F;&#x2F;入栈</span><br><span class="line">0x1001da0c0 &lt;+84&gt;:  b 0x1001da0c4 ; &lt;+88&gt; at main.m:68:30 &#x2F;&#x2F;跳转到 main.m 68:30 继续执行，其实就是下一条指令的地址</span><br><span class="line">0x1001da0c4 &lt;+88&gt;:  mov x29, x29 &#x2F;&#x2F;mov fp, fp</span><br><span class="line">0x1001da0c8 &lt;+92&gt;:  ldr x0, [sp, #0x8] &#x2F;&#x2F;出栈</span><br><span class="line">0x1001da0cc &lt;+96&gt;:  bl 0x1001da49c ; symbol stub for: objc_retainAutoreleasedReturnValue</span><br></pre></td></tr></table></figure>

<p>描述几个基本概念：</p>
<blockquote>
<p>母函数执行子函数前，会将寄存器中的原始值存储在栈中，即入栈；</p>
<p>子函数执行后，再从栈中将内容读取到寄存器，即出栈，接着继续执行后面的指令。</p>
<p>寄存器<a href="#4"><sup>[4]</sup></a>：</p>
<p>SP(Stack Pointer)：堆栈指针寄存器，指向栈顶地址</p>
<p>FP(Frame Pointer, R29)：帧指针寄存器，通常指向栈底地址，即指向母函数与被调用的子函数在栈中的交界</p>
<p>LR(Link Register, R30)：链接寄存器，保存子函数返回后执行的下一条指令的内存地址</p>
<p>指令<a href="#5"><sup>[5]</sup></a>：</p>
<p>B 函数地址：跳转到对应函数中执行</p>
<p>BL 函数地址：将下一条指令的地址存放到 LR(R30) 寄存器中，并跳转到对应函数中执行</p>
<p>MOV x0 x1：寄存器间传值或者寄存器与常量之间传值，即 R0 = R1，寄存器与内存之间传值用 STR 和 LDR</p>
<p>STR x0, [SP, #0x8]：将寄存器 x0 中的数据保存到 SP+0x8 地址值指向的存储空间(入栈)</p>
<p>LDR x0, [SP, #0x8]：将 SP+0x8 的地址值内的数据读取到寄存器 x0 中(出栈)</p>
</blockquote>
<p>当加了<code>__weak</code>修饰符后，编译器在<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleasedReturnValue</code>之间加入了入栈，跳转，出栈操作，导致<code>callerAcceptsOptimizedReturn(__builtin_return_address(0))</code>的值为 false，从而执行了<code>objc_autorelease</code>，加到了自动释放池之中。</p>
<p>依我看来，添加的几条指令有点多余。为什么编译器会加上这些指令呢？目前我不太明白。</p>
<p>但有方法可以去掉这几条指令，<strong>Build Settings -&gt; Apple Clang - Code Generation -&gt; Optimization Level<a href="#6"><sup>[6]</sup></a> -&gt; Debug</strong> 设置为除了 *<em><code>None[-O0]</code> *</em>以外的配置即可。运行之后，可以看到 AutoreleasePool 里不会再加入对象，但也出现一条信息：</p>
<blockquote>
<p>Project was compiled with optimization - stepping may behave oddly; variables may not be available.</p>
</blockquote>
<p>一般 Debug 下，配置为 <code>None[-O0]</code>，Release 下配置为 <code>Fastest，Smallest[-Os]</code>。那么知道在 Release 下一切正常即可。</p>
<p>相应地，对于尾调用优化在 <strong>Debug</strong> 下不起作用的情况，配置为 <code>Faster[-O2]</code>即可生效。</p>
<h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>对尾调用优化的介绍，这里有 2 篇文章介绍：</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾调用优化</a></p>
<p><a href="https://juejin.cn/post/6844903664050536455" target="_blank" rel="noopener">iOS objc_msgSend尾调用优化机制详解</a></p>
<p>其中第二篇文章中有写到，<strong>尾调用优化在Release模式下才会有，Debug模式下没有</strong>的情况，可以通过设置 Optimization Level 解决。</p>
<p>LLVM 编译优化是通过 Pass 实现的，查看当前 Optimization Level 对应的 Pass arguments<a href="#9"><sup>[9]</sup></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -OX -mllvm -debug-pass&#x3D;Arguments foo.c</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/09/yk8Urp7KCo2xZvs.png" alt="image.png"></p>
<p>上图是<code>Faster[-O2]</code>对应的 Pass Arguments，可以看到其中有一项是<code>-tailcallelim</code><a href="#10"><sup>[10]</sup></a>，这个 Pass 针对的就是尾调用优化。</p>
<blockquote>
<p><em>This file transforms calls of the current function (self recursion) followed by a return instruction with a branch to the entry of the function, creating a loop. This pass also implements the following extensions to the basic algorithm:</em><br><em>1. Trivial instructions between the call and return do not prevent the transformation from taking place, though currently the analysis cannot support moving any really useful instructions (only dead ones).</em><br><em>2. This pass transforms functions that are prevented from being tail recursive by an associative expression to use an accumulator variable, thus compiling the typical naive factorial or fib implementation into efficient code.</em><br><em>3. TRE is performed if the function returns void, if the return returns the result returned by the call, or if the function returns a run-time constant on all exits from the function. It is possible, though unlikely, that the return returns something else (like constant 0), and can still be TRE’d. It can be TRE’d if <strong>all other</strong> return instructions in the function return the exact same value.</em><br><em>4. If it can prove that callees do not access their caller stack frame, they are marked as eligible for tail call elimination (by the code generator).</em></p>
</blockquote>
<p>另：<code>Fast [-O, O1]</code> 中没有<code>-tailcallelim</code>，基于本人 MacBook 当前 LLVM 版本 Apple clang version 12.0.0 (clang-1200.0.32.27)，这个 StackOverflow 回答中<a href="#11"><sup>[11]</sup></a>罗列了各个级别对应的 Pass，不过是在 version 6.0 下，以新版本为主。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><em>[1]<a href="https://www.jianshu.com/p/63426e6bf7aa" target="_blank" rel="noopener">如何理解 Xcode 11 模板项目中 main.m 的变化？</a></em><span id="1"> </span></p>
</li>
<li><p><em>[2]<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></em><span id="2"> </span></p>
</li>
<li><p><em>[3]<a href="https://www.galloway.me.uk/2012/02/how-does-objc_retainautoreleasedreturnvalue-work/" target="_blank" rel="noopener">How does objc_retainAutoreleasedReturnValue work?</a></em><span id="3"> </span></p>
</li>
<li><p><em>[4]<a href="https://github.com/ARM-software/abi-aa/blob/master/aapcs64/aapcs64.rst#general-purpose-registers" target="_blank" rel="noopener">General-purpose Registers</a></em><span id="4"> </span></p>
</li>
<li><p><em>[5]<a href="https://developer.arm.com/documentation/dui0802/a/A64-Data-Transfer-Instructions?lang=en" target="_blank" rel="noopener">A64 Data Transfer Instructions</a></em><span id="5"> </span></p>
</li>
<li><p><em>[6]<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/MOSXAppProgrammingGuide/Performance/Performance.html#//apple_ref/doc/uid/TP40010543-CH9-102307" target="_blank" rel="noopener">Compiler-Level Optimizations</a></em><span id="6"> </span></p>
</li>
<li><p><em>[7]<a href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾调用优化</a></em></p>
</li>
<li><p><em>[8]<a href="https://juejin.cn/post/6844903664050536455" target="_blank" rel="noopener">iOS objc_msgSend尾调用优化机制详解</a></em></p>
</li>
<li><p><em>[9]<a href="https://stackoverflow.com/questions/35920795/list-of-optimizations-available-in-clang-and-llvm-opt" target="_blank" rel="noopener">List of optimizations available in clang and llvm opt</a></em><span id="9"> </span></p>
</li>
<li><p><em>[10]<a href="https://llvm.org/docs/Passes.html#tailcallelim-tail-call-elimination" target="_blank" rel="noopener">-tailcallelim: Tail Call Elimination</a></em><span id="10"> </span></p>
</li>
<li><p><em>[11]<a href="https://stackoverflow.com/questions/15548023/clang-optimization-levels" target="_blank" rel="noopener">Clang optimization levels</a></em><span id="11"> </span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
  </entry>
  <entry>
    <title>AssociatedObject关联对象</title>
    <url>/iOS%E5%9F%BA%E7%A1%80/AssociatedObject%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://juejin.im/post/5af86b276fb9a07aa34a59e6" target="_blank" rel="noopener">iOS底层原理总结-关联对象实现原理</a></p>
<p><a href="https://draveness.me/ao" target="_blank" rel="noopener">关联对象AssociatedObject完全解析</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1010478" target="_blank" rel="noopener">《map学习（下）— C++中的hash_map，unordered_map》</a></p>
<p>以上参考文章建议先阅读一遍，以下内容大同小异，为本人经过理解后的总结。</p>
<a id="more"></a>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般在分类Category添加的属性set/get方法的实现中会用到关联对象。如下方的实例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>下面来看下关联对象的底层实现。</p>
<p>在objc-runtime.mm中，可以看到<code>objc_setAssociateObject</code>的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击进入到<code>_object_set_associative_reference</code>中。（objc-references.mm)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    &#x2F;&#x2F; retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value &#x3D; value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            &#x2F;&#x2F; break any existing association.</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    j-&gt;second &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] &#x3D; refs;</span><br><span class="line">                (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D;  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理暂且放后头，先来看看<code>_object_set_associative_reference</code>方法中涉及到的几个类和数据结构。</p>
<h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><blockquote>
<p>// class AssociationsManager manages a lock / hash table singleton pair.</p>
<p>// Allocating an instance acquires the lock, and calling its assocations()</p>
<p>// method lazily allocates the hash table.</p>
</blockquote>
<p><code>AssociationsManager</code>类管理一个锁/哈希表单例对。</p>
<p>初始化一个实例将获取该锁，然后调用<code>assocations()</code>方法将懒加载其哈希表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spinlock_t AssociationsManagerLock;</span><br><span class="line"></span><br><span class="line">class AssociationsManager &#123;</span><br><span class="line">    &#x2F;&#x2F; associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map &#x3D;&#x3D; NULL)</span><br><span class="line">            _map &#x3D; new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="AssociationsHashMap"><a href="#AssociationsHashMap" class="headerlink" title="AssociationsHashMap"></a>AssociationsHashMap</h4><p>关联引用：<code>对象指针 -&gt; PtrPtrHashMap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef hash_map&lt;disguised_ptr_t, ObjectAssociationMap *&gt; AssociationsHashMap;</span><br></pre></td></tr></table></figure>

<p><code>AssociationsManager</code>中的哈希表，以<code>disguised_ptr_t</code>作为key值，<code>ObjectAssociationMap</code>指针变量作为映射值的哈希表。</p>
<h4 id="ObjectAssociationMap"><a href="#ObjectAssociationMap" class="headerlink" title="ObjectAssociationMap"></a>ObjectAssociationMap</h4><p>以传入的<code>void *key</code>作为key值，映射值为<code>ObjcAssociation</code>的哈希表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef hash_map&lt;void *, ObjcAssociation&gt; ObjectAssociationMap;</span><br></pre></td></tr></table></figure>

<h4 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a>ObjcAssociation</h4><p><code>ObjcAssociation</code>包含了<code>_policy</code>(策略)和<code>_value</code>(值)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">        uintptr_t _policy;</span><br><span class="line">        id _value;</span><br><span class="line">    public:</span><br><span class="line">        ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">        ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">        id value() const &#123; return _value; &#125;</span><br><span class="line">        </span><br><span class="line">        bool hasValue() &#123; return _value !&#x3D; nil; &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>对应关系如图：</p>
<p><img src="https://i.loli.net/2019/12/23/DxVqvQNu7sK8e25.png" alt="AssociatedObject实现原理.jpg"></p>
<p>全局有一个<code>AssociationsManager</code>，维护一个<code>AssociationsHashMap</code>，以当前实例对象的地址通过位运算得出<code>disguised_ptr_t</code>，作为key值，映射<code>ObjectAssociationMap</code>(含有当前实例对象的所有关联对象<code>ObjcAssociation</code>）。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>我们回到<code>_object_set_associative_reference</code>的实现当中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在锁之外保留新值（如果有）</span><br><span class="line">    ObjcAssociation old_association(0, nil);&#x2F;&#x2F;初始化一个ObjcAssociation来保存旧值</span><br><span class="line">    id new_value &#x3D; value ? acquireValue(value, policy) : nil;&#x2F;&#x2F;acquireValue方法来获取根据策略处理过的value</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());&#x2F;&#x2F;加载AssociationHashMap</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);&#x2F;&#x2F;通过取反位运算object地址获取disguised_object</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有新值</span><br><span class="line">            &#x2F;&#x2F; 断开任何现有的关联</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果存在ObjectAssociationMap</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果存在ObjcAssociation</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    j-&gt;second &#x3D; ObjcAssociation(policy, new_value);&#x2F;&#x2F;重新赋值</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);&#x2F;&#x2F;不存在，直接赋值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建新 association（第一次）</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] &#x3D; refs;</span><br><span class="line">                (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 设association为nil来断开关联</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D;  associations.end()) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果存在ObjectAssociationMap</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果存在ObjcAssociation</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 释放旧值（在锁之外）</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过添加的注释大概能够明白其中的思路。</p>
<p>首先初始化一个<code>old_association</code>来存储旧值，以便在最后释放（如果有值的话）；</p>
<p>然后根据<code>new_value</code>是否有值，有值则找到对应的<code>refs(ObjectAssociationMap)</code>，设置key值对应映射值为<code>ObjcAssociation(policy, new_value)</code>；</p>
<p><code>new_value</code>为<code>nil</code>则抹除<code>refs</code>;</p>
<p>最后在<code>spinLock</code>自旋锁之外释放旧值。</p>
<h4 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h4><p><code>objc_getAssociatedObject</code>方法的实现通过以上的分析可以大致理解，特别的地方在于会根据关联对象的策略<code>policy</code>来对<code>value</code>进行<code>objc_retain、objc_autorelease</code>。</p>
<h4 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object) </span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过<code>hasAssociatedObjects</code>判断是否有关联对象，有则调用<code>_object_remove_assocations</code>删除当前实例对象的关联对象。查找方法同<code>_object_set_associative_reference</code>，移除对应的辅助哈希表<code>ObjectAssociationMap</code>；最后遍历<code>elements</code>，释放关联对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() &#x3D;&#x3D; 0) return;</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">        if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            &#x2F;&#x2F; copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">            for (ObjectAssociationMap::iterator j &#x3D; refs-&gt;begin(), end &#x3D; refs-&gt;end(); j !&#x3D; end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; remove the secondary table.</span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另：综上描述可以得出，<code>AssociatedObject</code>的生成和释放在底层已做好<code>retain、release</code>操作（不是通过ARC编译时添加），不需要手动添加内存管理代码。</p>
<h3 id="问题：关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？"><a href="#问题：关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？" class="headerlink" title="问题：关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？"></a>问题：关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？</h3><p>关联对象可用于Category新增属性时添加实现，系统本身维护了一个单例<code>AssociationsManager</code>来维护关联对象的哈希表。关联对象被释放时不需要手动将关联对象的指针置空，底层已做好内存管理工作。（待润色）</p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
  </entry>
  <entry>
    <title>Category和Extension</title>
    <url>/iOS%E5%9F%BA%E7%A1%80/Category%E5%92%8CExtension/</url>
    <content><![CDATA[<h3 id="Category类别"><a href="#Category类别" class="headerlink" title="Category类别"></a>Category类别</h3><p>你可以使用<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">category</a>来定义现有类的其他方法（甚至是那些源码无法获取的类，而无需子类化）。通常，你可以使用类别将方法添加到现有类中，比如<code>Cocoa</code>框架中定义的方法那样。所添加的方法由子类继承，并且在运行时与类的原始方法没有区别。您还可以使用自己类的类别来：</p>
<a id="more"></a>

<ol>
<li>将自己的类的实现分发到单独的源文件中-例如，您可以将一个大类的方法分为几个类别，然后将每个类别放入不同的文件中。</li>
<li>声明私有方法。</li>
</ol>
<p>通过在类别名称下的接口文件中声明方法并在相同名称下的实现文件中定义方法，可以将方法添加到类中。类别名称表示，方法是对在别处声明的类的扩展，而不是新的类。</p>
<h3 id="Extension扩展"><a href="#Extension扩展" class="headerlink" title="Extension扩展"></a>Extension扩展</h3><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Class Extensions Extend the Internal Implementation</a></p>
<p>类扩展与类别具有某些相似性，但是只能将其添加到您在编译时拥有源代码的类中（该类与该类扩展同时进行编译）。由类扩展声明的方法是在原始类的<code>@implementation</code>块中实现的，因此，例如，您不能在框架类（例如<code>Cocoa</code>，或<code>NSString</code>之类的<code>Cocoa Touch</code>类）上声明类扩展。</p>
<h3 id="问题：分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？"><a href="#问题：分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？" class="headerlink" title="问题：分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？"></a>问题：分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？</h3><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><p><a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">深入理解Objective-C:Category</a></p>
<p><a href="https://juejin.im/post/5aef0a3b518825670f7bc0f3" target="_blank" rel="noopener">iOS底层原理总结-Category的本质</a></p>
<p>分类是<code>Objective-C 2.0</code>之后添加的语言特性，主要作用是给已经存在的类添加方法。</p>
<p>扩展是对类私有变量和私有方法的声明。</p>
<h5 id="分类的局限性："><a href="#分类的局限性：" class="headerlink" title="分类的局限性："></a>分类的局限性：</h5><ol>
<li>分类可以添加属性，但不能自动生成成员变量以及其set/get方法，可以通过关联对象来解决。</li>
<li>如果分类中的方法和原有方法同名，运行时会优先调用category中的方法，覆盖掉类中原有的方法（调用顺序category-&gt;本类-&gt;父类）。</li>
<li>如果多个category存在同名的方法，最后一个参与编译的分类中的实现将会被调用。</li>
</ol>
<h5 id="结构体："><a href="#结构体：" class="headerlink" title="结构体："></a>结构体：</h5><ol>
<li>类的名字<code>name</code></li>
<li>类<code>cls</code></li>
<li>category中所有给类添加的实例方法的列表<code>instanceMethods</code></li>
<li>category中所有添加的类方法的列表<code>classMethods</code></li>
<li>category实现的所有协议的列表<code>protocols</code></li>
<li>category中添加的所有属性<code>instanceProperties</code></li>
</ol>
<p>分类的结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods; &#x2F;&#x2F; 对象方法</span><br><span class="line">    struct method_list_t *classMethods; &#x2F;&#x2F; 类方法</span><br><span class="line">    struct protocol_list_t *protocols; &#x2F;&#x2F; 协议</span><br><span class="line">    struct property_list_t *instanceProperties; &#x2F;&#x2F; 属性</span><br><span class="line">    &#x2F;&#x2F; Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
  </entry>
  <entry>
    <title>Tagged Pointer in iOS</title>
    <url>/iOS%E5%9F%BA%E7%A1%80/Tagged%20Pointer%20in%20iOS/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>问题1：下面的代码输出是什么？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSNumber</span> *weakNumber;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *weakString;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSDate</span> *weakDate;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    weakObj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    weakNumber = [<span class="built_in">NSNumber</span> numberWithInt:num];</span><br><span class="line">    weakString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"string%d"</span>, num];</span><br><span class="line">    weakDate   = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakObj is %@"</span>, weakObj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakNumber is %@"</span>, weakNumber);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakString is %@"</span>, weakString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"weakDate is %@"</span>, weakDate);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>问题2：下面的代码1、2会崩溃吗？如何解决？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghijklmn"</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题3：下面的代码1、2会崩溃吗？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>) </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> someProperty; </span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>) </span></span><br><span class="line"><span class="keyword">@dynamic</span> someProperty; </span><br><span class="line">- (<span class="keyword">void</span>)setSomeProperty:(<span class="built_in">CGFloat</span>)someProperty&#123; </span><br><span class="line">   <span class="keyword">return</span> objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(someProperty), @(someProperty), OBJC_ASSOCIATION_ASSIGN); </span><br><span class="line">&#125; </span><br><span class="line">- (<span class="built_in">CGFloat</span>)someProperty&#123; </span><br><span class="line">   <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(someProperty)) floatValue]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">self</span>.view.someProperty = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, @(<span class="keyword">self</span>.view.someProperty));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">self</span>.view.someProperty = <span class="number">100.1</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, @(<span class="keyword">self</span>.view.someProperty));</span><br></pre></td></tr></table></figure>

<p>带着这3个问题，我们先来了解一下Tagged Pointer这一概念。</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>（本篇文章基于<a href="https://opensource.apple.com/source/objc4/objc4-750/" target="_blank" rel="noopener">objc4-750</a>版本，由于objc源码版本更新迭代，部分内容与参考文章有出入。）</p>
<p>Tagged Pointer这一概念最早是在<a href="https://opensource.apple.com/source/objc4/objc4-493.9/runtime/" target="_blank" rel="noopener">objc4-493.9</a>中出现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__  &amp;&amp;  __LP64__</span></span><br><span class="line"><span class="comment">// Register a tagged pointer class.</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> _objc_insert_tagged_isa(<span class="keyword">unsigned</span> <span class="keyword">char</span> slotNumber, Class isa)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在64位架构下，普通变量如NSInteger所占用的内存由32位架构下的4字节变成8个字节，NSNumber对象指针由32位架构下的4字节变成8字节，对象指针所指向的内存地址由32位架构下的8字节变成16字节，这带来的内存占用简直是灾难性的。</p>
<p>所以，从Mac OS X 10.7和iOS 5开始（64位），苹果同步提出了Tagged Pointer这样一个技巧，来优化NSNumber、NSString等对象类型，提升读取速度和减少其内存使用，具体的如唐巧老师这一篇<a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">文章</a>中写道：</p>
<blockquote>
<ol>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate。</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ol>
</blockquote>
<p>如下图，未引入Tagged Pointer以及引入Tagged Pointer下的内存占用情况：</p>
<p><img src="https://i.loli.net/2019/12/23/VgFw2tWqhKzneH6.png" alt="Tagged Pointer.jpg"></p>
<p>(备注：Tagged Pointer的布局随着不同的iOS版本而变化)</p>
<p>也就是说，当数据作为标记指针被优化时，该指针存储在栈上；没有isa指针，不是一个对象，以Tag + Payload的形式存储，且不需要编译器添加Retain和Release来做内存管理；占用的内存空间约为原来的1/3，读取、创建效率提升明显；如果60bits的payload无法完全表达数据，数据还是将会作为对象指针指向堆上的内存地址的形式存储。</p>
<p>那上面3个问题的答案就显而易见了：</p>
<p>问题1：除weakObj为null，其余3个的值都能正常打印。</p>
<p>问题2：代码1部分将崩溃（如果不崩溃请改为10000），系多线程异步并发执行多次release旧值导致crash，可以通过加锁来解决；代码2不会崩溃，因为对于标记指针将不作内存管理，直接赋值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__attribute__((aligned(<span class="number">16</span>)))</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题3：<a href="[http://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88](http://zh.wikipedia.org/wiki/迷途指针)">悬垂指针</a>调用crash，跟问题1的考察点一致，详见<a href="https://juejin.im/post/5bd3e59e51882578247082d3" target="_blank" rel="noopener">问题来源</a>作者的描述。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>上述3个问题分别来自（侵删），感谢作者：</p>
<ul>
<li><a href="https://wenghengcong.com/posts/b6becb26/" target="_blank" rel="noopener">内存管理（二）Tagged Pointer</a> by wenghengcong</li>
<li><a href="https://juejin.im/post/5c931b59e51d45733067e6b9" target="_blank" rel="noopener">小码哥iOS学习笔记第二十四天:Tagged Pointer</a> by SketchK</li>
<li><a href="https://juejin.im/post/5bd3e59e51882578247082d3" target="_blank" rel="noopener">由Tagged Pointer联想到的一个问题</a> by 冰凌天</li>
</ul>
<p>另外：</p>
<p><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">深入理解Tagged Pointer</a> by 唐巧</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Friday Q&amp;A 2012-07-27:Let’s Build Tagged Pointers</a> by Mike Ash</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">Friday Q&amp;A 2015-07-31:Tagged Pointer Strings</a> by Mike Ash <a href="http://www.cocoachina.com/articles/13449" target="_blank" rel="noopener">翻译</a></p>
<h3 id="iOS12"><a href="#iOS12" class="headerlink" title="iOS12"></a>iOS12</h3><p>然而，问题并没有结束。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n %p %@"</span>, string, [string <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>上述代码在iPhone6s真机(iOS12)下调试，打印为：</p>
<p><code>0x87c2ce80a4d444ae NSTaggedPointerString</code></p>
<p>这是什么跟什么？！！等等，按照上文分析以及<a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">Friday Q&amp;A 2015-07-31:Tagged Pointer Strings</a>里描述的，<code>@&quot;a&quot;</code>的对象指针地址应该是<code>0x?????????????61?</code>才对啊！！不信邪的再次运行：</p>
<p>0xcc5f2b03900c91ce NSTaggedPointerString</p>
<p>:slightly_smiling_face:</p>
<p>变了！！！不得了不得了！</p>
<p>尝试在iPhone5s模拟器(iOS10)上运行：</p>
<p><code>0xa000000000000611 NSTaggedPointerString</code></p>
<p>iPhone5s模拟器(iOS11)：</p>
<p><code>0xa000000000000611 NSTaggedPointerString</code></p>
<p>看来问题就出在iOS12上，让我们结合源码来解读。</p>
<h4 id="initializeTaggedPointerObfuscator"><a href="#initializeTaggedPointerObfuscator" class="headerlink" title="initializeTaggedPointerObfuscator"></a>initializeTaggedPointerObfuscator</h4><p>让我们从源码(<a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-runtime-new.mm.auto.html" target="_blank" rel="noopener">objc4-750 objc-runtime-new.mm</a>)中了解。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* initializeTaggedPointerObfuscator</span></span><br><span class="line"><span class="comment">* Initialize objc_debug_taggedpointer_obfuscator with randomness.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The tagged pointer obfuscator is intended to make it more difficult</span></span><br><span class="line"><span class="comment">* for an attacker to construct a particular object as a tagged pointer,</span></span><br><span class="line"><span class="comment">* in the presence of a buffer overflow or other write control over some</span></span><br><span class="line"><span class="comment">* memory. The obfuscator is XORed with the tagged pointers when setting</span></span><br><span class="line"><span class="comment">* or retrieving payload values. They are filled with randomness on first</span></span><br><span class="line"><span class="comment">* use.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">initializeTaggedPointerObfuscator(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdkIsOlderThan(<span class="number">10</span>_14, <span class="number">12</span>_0, <span class="number">12</span>_0, <span class="number">5</span>_0, <span class="number">3</span>_0) ||</span><br><span class="line">        <span class="comment">// Set the obfuscator to zero for apps linked against older SDKs,</span></span><br><span class="line">        <span class="comment">// in case they're relying on the tagged pointer representation.</span></span><br><span class="line">        DisableTaggedPointerObfuscation) &#123;</span><br><span class="line">        objc_debug_taggedpointer_obfuscator = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Pull random data into the variable, then shift away all non-payload bits.</span></span><br><span class="line">        arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,</span><br><span class="line">                       <span class="keyword">sizeof</span>(objc_debug_taggedpointer_obfuscator));</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &amp;= ~_OBJC_TAG_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，源码中用到了混淆器函数initializeTaggedPointerObfuscator来对标记指针做异或运算处理，以避免攻击者在缓冲区溢出以及其他可写控制内存伪造标记指针。在iOS12.0之前的版本将不做处理。</p>
<p>Product -&gt; Scheme -&gt; Edit Scheme或者按<code>command + shift + ,</code>(即<code>command + &lt;</code>)，在Arguments添加环境变量(Environment Variables)name为<code>OBJC_DISABLE_TAG_OBFUSCATION</code>，值为<code>YES</code>。</p>
<p>再次在iPhone6s真机(iOS12)下调试，打印为：</p>
<p><code>0xa000000000000611 NSTaggedPointerString</code></p>
<p>正常了！</p>
<h4 id="源码中其他有意思的地方"><a href="#源码中其他有意思的地方" class="headerlink" title="源码中其他有意思的地方"></a>源码中其他有意思的地方</h4><h5 id="LP64"><a href="#LP64" class="headerlink" title="__LP64__"></a>__LP64__</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_HAVE_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在为64位运行时进行编译时，编译器定义<a href="https://stackoverflow.com/questions/18861046/how-to-determine-if-compiling-for-64-bit-ios-in-xcode" target="_blank" rel="noopener">__LP64__</a>宏。这里通过__LP64__宏来判断是否有标记指针。</p>
<h5 id="MSB和LSB"><a href="#MSB和LSB" class="headerlink" title="MSB和LSB"></a>MSB和LSB</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>MSB(Most Significant Bit)：最高有效位，对数值的影响最大；LSB(Least Significant Bit)：最低有效位。参考：<a href="https://www.cnblogs.com/lingyejun/p/8312838.html" target="_blank" rel="noopener">清晰讲解LSB、MSB和大小端模式及网络字节序</a>。这里对标记指针的内部空间分配进行管理，在Mac上调试，字符串<code>@&quot;a&quot;</code>的标记指针地址为<code>0x6115</code>，tag和tag index从最低有效位开始；iPhone上调试，tag和tag index从最高有效位开始，如下图所示，<code>1010</code>即tag + tag index(<code>OBJC_TAG_NSString = 2</code>)。</p>
<p><img src="https://i.loli.net/2019/12/20/4Unysd2SD3Kr8of.png" alt="WX20191220-113101@2x.png"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="keyword">enum</span> objc_tag_index_t : uint16_t</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> uint16_t objc_tag_index_t;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 60-bit payloads</span></span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 60-bit reserved</span></span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 52-bit payloads</span></span><br><span class="line">    OBJC_TAG_Photos_1          = <span class="number">8</span>,</span><br><span class="line">    OBJC_TAG_Photos_2          = <span class="number">9</span>,</span><br><span class="line">    OBJC_TAG_Photos_3          = <span class="number">10</span>,</span><br><span class="line">    OBJC_TAG_Photos_4          = <span class="number">11</span>,</span><br><span class="line">    OBJC_TAG_XPC_1             = <span class="number">12</span>,</span><br><span class="line">    OBJC_TAG_XPC_2             = <span class="number">13</span>,</span><br><span class="line">    OBJC_TAG_XPC_3             = <span class="number">14</span>,</span><br><span class="line">    OBJC_TAG_XPC_4             = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  &amp;&amp;  !defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> objc_tag_index_t objc_tag_index_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
  </entry>
  <entry>
    <title>测试任意指针是否为有效的Objective-C对象</title>
    <url>/iOS/%E6%B5%8B%E8%AF%95%E4%BB%BB%E6%84%8F%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9C%89%E6%95%88%E7%9A%84Objective-C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>翻译自：<a href="https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/" target="_blank" rel="noopener">https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/</a></p>
<p>仅供学习交流，侵删。</p>
<a id="more"></a>

<h2 id="以下为正文内容："><a href="#以下为正文内容：" class="headerlink" title="以下为正文内容："></a>以下为正文内容：</h2><p>假设你随机选取一个指针，我们能否知道它是否指向有效的Objective-C对象？当然不能有崩溃。。。emm，没有简单的解决方案。在这篇文章中，我给出了64位结构的解决方案。其提供的代码只在具有modern Objective-C运行时的macOS10.12.1和iOS10.1.1上测试过。</p>
<p>没有太多关于这个问题的文档。这里有一篇来自<a href="https://www.cocoawithlove.com/2010/10/testing-if-arbitrary-pointer-is-valid.html" target="_blank" rel="noopener">Matt Gallagher</a>的文章，写于2010年，但其中的内容已经过时且可能不能够正常使用。本文的大部分信息来自于：</p>
<p><a href="https://opensource.apple.com/source/objc4/objc4-706/" target="_blank" rel="noopener">objc4-706 from macOS10.12</a></p>
<p><a href="http://lldb.llvm.org/source.html" target="_blank" rel="noopener">LLDB git repository(November 2016)</a></p>
<p>###免责声明</p>
<p>本文的内容以及源代码依赖于Objective-C运行时的内部结构。对其正确性无法保证，并可能会随着macOS/iOS的更新而破坏。不要在实际App中使用这代码！</p>
<p>实际上我刚刚开始是基于objc4-680(mac OS 10.11.6)源码写这篇文章。但在发布前，苹果发布了objc4-706(macOS 10.12)的源码。正如下方图片所见，一些依赖的内部结构发生了改变：</p>
<p><img src="https://i.loli.net/2019/12/17/4wyCSTl1iHesEIY.png" alt="objc4-680_objc4-706.png"></p>
<h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针是引用某个内存地址的整数。然而，在iOS和macOS上，有2种指针：普通指针和标记指针。让我们开始解决标记指针的问题。</p>
<h3 id="标记指针"><a href="#标记指针" class="headerlink" title="标记指针"></a>标记指针</h3><p>在iOS7和Mac OS X 10.7 64位架构，引进了标记指针。带标记的指针是一种特殊的指针，其数据直接存储在该指针中，而不是通过内存分配。其具有明显的性能优势。</p>
<p>标记指针在objc-internal.h中声明。在macOS 10.11以及更早的版本中，标记指针较为简单：</p>
<ul>
<li><p>60位的有效载荷</p>
</li>
<li><p>3位的标记索引</p>
</li>
<li><p>1位用来辨别标记指针对象或普通对象</p>
</li>
</ul>
<p>在macOS 10.12，标记指针布局已更改为还支持52位有效载荷和更多的标记索引：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tag indexes 0..&lt;7 have a 60-bit payload.</span></span><br><span class="line"><span class="comment">// Tag index 7 is reserved.</span></span><br><span class="line"><span class="comment">// Tag indexes 8..&lt;264 have a 52-bit payload.</span></span><br><span class="line"><span class="comment">// Tag index 264 is reserved.</span></span><br></pre></td></tr></table></figure>

<p>标记索引告诉您标记指针所表示的类：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"> </span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"> </span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用声明在objc-internal.h中的函数，检查指针是否为标记指针很简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((intptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> objc_tag_index_t </span><br><span class="line">_objc_getTaggedPointerTag(<span class="keyword">const</span> <span class="keyword">void</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t basicTag = ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    uintptr_t extTag =   ((uintptr_t)ptr &gt;&gt; _OBJC_TAG_EXT_INDEX_SHIFT) &amp; _OBJC_TAG_EXT_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (objc_tag_index_t)(extTag + OBJC_TAG_First52BitPayload);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (objc_tag_index_t)basicTag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，这些函数是静态内联函数，没有对外开放，我们别无选择，只能在代码中复制以实现。</p>
<p>另一方面，获取给定标记所注册的类的函数是对外的，可以使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns the registered class for the given tag.</span></span><br><span class="line"><span class="comment"> Returns nil if the tag is valid but has no registered class.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> This function searches the exported function: _objc_getClassForTag(objc_tag_index_t tag)</span></span><br><span class="line"><span class="comment"> declared in https://opensource.apple.com/source/objc4/objc4-706/runtime/objc-internal.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class _objc_getClassForTag(objc_tag_index_t tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> _objc_getClassForTag_searched = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> Class (*_objc_getClassForTag_func)(objc_tag_index_t) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!_objc_getClassForTag_searched)</span><br><span class="line">    &#123;</span><br><span class="line">        _objc_getClassForTag_func = (Class(*)(objc_tag_index_t))dlsym(RTLD_DEFAULT, <span class="string">"_objc_getClassForTag"</span>);</span><br><span class="line">        _objc_getClassForTag_searched = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(_objc_getClassForTag_func == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"*** Could not find _objc_getClassForTag()!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(_objc_getClassForTag_func != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_getClassForTag_func(tag);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，很容易创建一个函数来检查指针是否是标记指针，从而是有效的Objective-C对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Test if a pointer is a tagged pointer</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param inPtr is the pointer to check</span></span><br><span class="line"><span class="comment"> @param outClass returns the registered class for the tagged pointer.</span></span><br><span class="line"><span class="comment"> @return true if the pointer is a tagged pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> IsObjcTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> *inPtr, Class *outClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> isTaggedPointer = _objc_isTaggedPointer(inPtr);</span><br><span class="line">    <span class="keyword">if</span>(outClass != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isTaggedPointer)</span><br><span class="line">        &#123;</span><br><span class="line">            objc_tag_index_t tagIndex = _objc_getTaggedPointerTag(inPtr);</span><br><span class="line">            *outClass = _objc_getClassForTag(tagIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *outClass = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> isTaggedPointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想了解更多关于标记指针你可以阅读下面2篇来自Mike Ash的文章：</p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">Friday Q&amp;A 2013-09-27:ARM64 and You</a></p>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Friday Q&amp;A 2012-07-27:Let’s Build Tagged Pointers</a></p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>有效指针必须与指针大小对齐。尝试在<a href="http://llvm.org/svn/llvm-project/lldb/trunk/examples/summaries/cocoa/objc_runtime.py" target="_blank" rel="noopener">objc_runtime.py</a>中的python函数<code>is_valid_pointer</code>中打印指针时，将在LLDB中进行此类检查：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def is_valid_pointer(pointer, pointer_size, allow_tagged=<span class="number">0</span>, allow_NULL=<span class="number">0</span>):</span><br><span class="line">    logger = lldb.formatters.Logger.Logger()</span><br><span class="line">    <span class="keyword">if</span> pointer is None:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> pointer == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> allow_NULL</span><br><span class="line">    <span class="keyword">if</span> allow_tagged and (pointer % <span class="number">2</span>) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ((pointer % pointer_size) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>最后的检查验证指针是否与指针大小对齐。我们可以实现相同的检查：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((uintptr_t)inPtr % <span class="keyword">sizeof</span>(uintptr_t)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位的使用"><a href="#位的使用" class="headerlink" title="位的使用"></a>位的使用</h3><p>LLDB源码在objc_runtime.py中还有一个有趣的函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># Objective-C runtime has a rule that pointers <span class="keyword">in</span> a class_t will only have bits <span class="number">0</span> thru <span class="number">46</span> set</span><br><span class="line"><span class="meta"># so <span class="meta-keyword">if</span> any pointer has bits 47 thru 63 high we know that this is not a</span></span><br><span class="line"><span class="meta"># valid isa</span></span><br><span class="line">@staticmethod</span><br><span class="line">def is_allowed_pointer(pointer):</span><br><span class="line">    logger = lldb.formatters.Logger.Logger()</span><br><span class="line">    <span class="keyword">if</span> pointer is None:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ((pointer &amp; <span class="number">0xFFFF800000000000</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>同样，我们可以轻松实现相同的检查：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(((uintptr_t)inPtr &amp; <span class="number">0xFFFF800000000000</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有效可读的内存"><a href="#有效可读的内存" class="headerlink" title="有效可读的内存"></a>有效可读的内存</h3><p>为了有效，指针应该指向有效可读的内存。我们可以用<code>vm_region_64()</code>来确保内存可读，<code>vm_read()</code>确保内存有效：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Test if the pointer points to readable and valid memory.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param inPtr is the pointer</span></span><br><span class="line"><span class="comment"> @return true if the pointer points to readable and valid memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> IsValidReadableMemory(<span class="keyword">const</span> <span class="keyword">void</span> *inPtr)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t error = KERN_SUCCESS;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Check for read permissions</span></span><br><span class="line">    <span class="keyword">bool</span> hasReadPermissions = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    vm_size_t vmsize;</span><br><span class="line">    vm_address_t address = (vm_address_t)inPtr;</span><br><span class="line">    vm_region_basic_info_data_t info;</span><br><span class="line">    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line"> </span><br><span class="line">    memory_object_name_t object;</span><br><span class="line"> </span><br><span class="line">    error = vm_region_64(mach_task_self(), &amp;address, &amp;vmsize, VM_REGION_BASIC_INFO, (vm_region_info_t)&amp;info, &amp;info_count, &amp;object);</span><br><span class="line">    <span class="keyword">if</span>(error != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// vm_region/vm_region_64 returned an error</span></span><br><span class="line">        hasReadPermissions = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hasReadPermissions = (info.protection &amp; VM_PROT_READ);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(!hasReadPermissions)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Read the memory</span></span><br><span class="line">    vm_offset_t readMem = <span class="number">0</span>;</span><br><span class="line">    mach_msg_type_number_t size = <span class="number">0</span>;</span><br><span class="line">    error = vm_read(mach_task_self(), (vm_address_t)inPtr, <span class="keyword">sizeof</span>(uintptr_t), &amp;readMem, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(error != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// vm_read returned an error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证isa指针并获取Class指针"><a href="#验证isa指针并获取Class指针" class="headerlink" title="验证isa指针并获取Class指针"></a>验证isa指针并获取Class指针</h3><p>现在我们知道当前地址指向有效可读的内存，我们可以提取可能的isa指针并获取Class指针。由Greg Parker在[[objc explain]:Non_pointer isa](<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)中记录到：" target="_blank" rel="noopener">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html)中记录到：</a></p>
<blockquote>
<p><em>If you are writing a debugger-like tool, the Objective-C runtime exports some variables to help decode isa fields. objc_debug_isa_class_mask describes which bits are the class pointer: (isa &amp; class_mask) == class pointer. objc_debug_isa_magic_mask and objc_debug_isa_magic_value describe some bits that help distinguish valid isa fields from other invalid values: (isa &amp; magic_mask) == magic_value for isa fields that are not raw class pointers. These variables may change in the future so do not use them in application code.</em></p>
</blockquote>
<p>以下是验证isa指针并提取Class指针的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">uintptr_t isa = (*(uintptr_t *)inPtr);</span><br><span class="line">Class ptrClass = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((isa &amp; ~ISA_MASK) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ptrClass = (Class)isa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((isa &amp; ISA_MAGIC_MASK) == ISA_MAGIC_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrClass = (Class)(isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptrClass = (Class)isa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(ptrClass == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证Class是否存在"><a href="#验证Class是否存在" class="headerlink" title="验证Class是否存在"></a>验证Class是否存在</h3><p>现在我们获取到了Class，我们可以检查Objective-C运行时是否知道它：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isKnownClass = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> numClasses = <span class="number">0</span>;</span><br><span class="line">Class *classesList = objc_copyClassList(&amp;numClasses);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (classesList[i] == ptrClass)</span><br><span class="line">    &#123;</span><br><span class="line">        isKnownClass = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free(classesList);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!isKnownClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤掉一些误报"><a href="#过滤掉一些误报" class="headerlink" title="过滤掉一些误报"></a>过滤掉一些误报</h3><p>Greg Parker提供了一个<a href="https://twitter.com/gparker/status/801894068502433792" target="_blank" rel="noopener">好技巧</a>，通过检查指针分配的大小是否大于类实例的大小来过滤掉一些误报：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">size_t pointerSize = malloc_size(inPtr);</span><br><span class="line"><span class="keyword">if</span>(pointerSize &gt; <span class="number">0</span> &amp;&amp; pointerSize &lt; class_getInstanceSize(ptrClass))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在，我们拥有了用于构建一个函数的所有元素，该函数返回一个布尔值，该布尔值指示指针是否为Objective-C对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Test if a pointer is an Objective-C object</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param inPtr is the pointer to check</span></span><br><span class="line"><span class="comment"> @return true if the pointer is an Objective-C object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> IsObjcObject(<span class="keyword">const</span> <span class="keyword">void</span> *inPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NULL pointer is not an Objective-C object</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(inPtr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check for tagged pointers</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(IsObjcTaggedPointer(inPtr, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check if the pointer is aligned</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (((uintptr_t)inPtr % <span class="keyword">sizeof</span>(uintptr_t)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// From LLDB:</span></span><br><span class="line">    <span class="comment">// Objective-C runtime has a rule that pointers in a class_t will only have bits 0 thru 46 set</span></span><br><span class="line">    <span class="comment">// so if any pointer has bits 47 thru 63 high we know that this is not a valid isa</span></span><br><span class="line">    <span class="comment">// See http://llvm.org/svn/llvm-project/lldb/trunk/examples/summaries/cocoa/objc_runtime.py</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(((uintptr_t)inPtr &amp; <span class="number">0xFFFF800000000000</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check if the memory is valid and readable</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(!IsValidReadableMemory(inPtr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Get the Class from the pointer</span></span><br><span class="line">    <span class="comment">// From http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html :</span></span><br><span class="line">    <span class="comment">// If you are writing a debugger-like tool, the Objective-C runtime exports some variables</span></span><br><span class="line">    <span class="comment">// to help decode isa fields. objc_debug_isa_class_mask describes which bits are the class pointer:</span></span><br><span class="line">    <span class="comment">// (isa &amp; class_mask) == class pointer.</span></span><br><span class="line">    <span class="comment">// objc_debug_isa_magic_mask and objc_debug_isa_magic_value describe some bits that help</span></span><br><span class="line">    <span class="comment">// distinguish valid isa fields from other invalid values:</span></span><br><span class="line">    <span class="comment">// (isa &amp; magic_mask) == magic_value for isa fields that are not raw class pointers.</span></span><br><span class="line">    <span class="comment">// These variables may change in the future so do not use them in application code.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     </span><br><span class="line">    uintptr_t isa = (*(uintptr_t *)inPtr);</span><br><span class="line">    Class ptrClass = <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((isa &amp; ~ISA_MASK) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrClass = (Class)isa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((isa &amp; ISA_MAGIC_MASK) == ISA_MAGIC_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            ptrClass = (Class)(isa &amp; ISA_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptrClass = (Class)isa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(ptrClass == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Verifies that the found Class is a known class.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">bool</span> isKnownClass = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numClasses = <span class="number">0</span>;</span><br><span class="line">    Class *classesList = objc_copyClassList(&amp;numClasses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (classesList[i] == ptrClass)</span><br><span class="line">        &#123;</span><br><span class="line">            isKnownClass = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classesList);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(!isKnownClass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// From Greg Parker</span></span><br><span class="line">    <span class="comment">// https://twitter.com/gparker/status/801894068502433792</span></span><br><span class="line">    <span class="comment">// You can filter out some false positives by checking malloc_size(obj) &gt;= class_getInstanceSize(cls).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    size_t pointerSize = malloc_size(inPtr);</span><br><span class="line">    <span class="keyword">if</span>(pointerSize &gt; <span class="number">0</span> &amp;&amp; pointerSize &lt; class_getInstanceSize(ptrClass))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了测试此功能，我构建了一个简单的iOS应用来检查各种指针。这是在iOS 10.1.1（64位）上运行时的输出：</p>
<p><img src="https://i.loli.net/2019/12/18/xtROaqd3iEQ8jDh.png" alt="tests.png"></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/IsObjcObject.c" target="_blank" rel="noopener">IsObjcObject.c</a></p>
<p><a href="https://blog.timac.org/2016/1124-testing-if-an-arbitrary-pointer-is-a-valid-objective-c-object/IsObjcObject.zip" target="_blank" rel="noopener">Sources of the test app</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><a href="https://opensource.apple.com/source/objc4/objc4-706/" target="_blank" rel="noopener">objc4-706</a> from macOS 10.12</p>
</li>
<li><p><a href="https://lldb.llvm.org/resources/contributing.html" target="_blank" rel="noopener">LLDB git repository</a>(November 2016)</p>
</li>
<li><p><a href="https://www.cocoawithlove.com/2010/10/testing-if-arbitrary-pointer-is-valid.html" target="_blank" rel="noopener">Testing if an arbitrary pointer is valid object pointer</a> from Matt Gallagher</p>
</li>
<li><p><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" target="_blank" rel="noopener">Friday Q&amp;A 2013-09-27:ARM64 and You</a> from Mike Ash</p>
</li>
<li><p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Friday Q&amp;A 2012-07-27:Let’s Build Tagged Pointers</a> from Mike Ash</p>
</li>
<li><p>[[objc explain]:Non_pointer isa](<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</a>) from Greg Parker</p>
</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>2016.11.24：根据Greg Parker的反馈进行了2处更改：</p>
<ul>
<li>过滤掉一些误报</li>
<li>使用<code>objc_copyClassList()</code>来代替<code>objc_getClassList()</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Aspects解读（一）</title>
    <url>/iOS/Aspects%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Aspects是一个基于runtime运行时实现的轻量级AOP编程库，整个库代码不足千行，但干货满满。</p>
<p>阅读本文前，希望你具备：</p>
<p>1.看过Block源码</p>
<p>2.了解过运行时</p>
<p>Aspects源码地址：<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Github</a>(版本：Aspects v1.4.2)</p>
<p>Block源码地址：<a href="https://opensource.apple.com/source/libclosure/libclosure-73/Block_private.h.auto.html" target="_blank" rel="noopener">libclosure-73/Block_private.h</a></p>
<p>runtime源码地址：<a href="https://opensource.apple.com/source/objc4/objc4-750" target="_blank" rel="noopener">objc4-750</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p>
<a id="more"></a>

<p>感谢以下文章以及苹果文档给予我阅读源码上的帮助(侵删)：</p>
<p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<p><a href="https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html" target="_blank" rel="noopener">do…while(0)的妙用</a></p>
<p><a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">Objective-C中的消息与消息转发</a></p>
<p><a href="https://www.jianshu.com/p/1849068b7833" target="_blank" rel="noopener">探究Block之MethodSignature</a></p>
<p><a href="https://juejin.im/post/5a459f6c51882538fe6316d5" target="_blank" rel="noopener">你真的会判断_objc_msgForward_stret吗</a></p>
<p>这篇笔记主要是记录阅读Aspects源码时遇到的知识点以及思路分析整理，如有错误望指正！</p>
<p>那我们开始吧，首先介绍库中部分函数实现的知识点。</p>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Aspects.h&quot;</span><br><span class="line">#import &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;message.h&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void aspect_performLocked(dispatch_block_t block) &#123;</span><br><span class="line">    static OSSpinLock aspect_lock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">    OSSpinLockLock(&amp;aspect_lock);</span><br><span class="line">    block();</span><br><span class="line">    OSSpinLockUnlock(&amp;aspect_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OSAtomic.h 引入自旋锁OSSpinLock，通过函数<code>aspect_performLocked</code>以保证线程安全。然而OSSpinLock存在<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">优先级反转问题</a>，苹果已在 iOS10 设其为deprecated，部分开发者提issue改为<code>os_unfair_lock</code>，作者<a href="https://github.com/steipete/Aspects/issues/128" target="_blank" rel="noopener">没有采纳</a>。</p>
<p>###do{}while(0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define AspectLog(...)</span><br><span class="line">&#x2F;&#x2F;#define AspectLog(...) do &#123; NSLog(__VA_ARGS__); &#125;while(0)</span><br><span class="line">#define AspectLogError(...) do &#123; NSLog(__VA_ARGS__); &#125;while(0)</span><br></pre></td></tr></table></figure>

<p>需要注意<code>do{}while(0)</code>的使用，这种定义方式在Linux内核等代码中大量使用，主要是为了<a href="https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html]" target="_blank" rel="noopener">多行宏定义</a>的实现。</p>
<p>###AspectInfo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里定义了AspectInfo类，遵循Aspects.h头文件中声明的&lt;AspectInfo&gt;协议，主要保留了hook的对象以及原始函数实现，instance用<code>unsafe_unretained</code>修饰，即对需要hook的实例对象或类对象弱引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)arguments &#123;</span><br><span class="line">    if (!_arguments) &#123;</span><br><span class="line">        _arguments &#x3D; self.originalInvocation.aspects_arguments;</span><br><span class="line">    &#125;</span><br><span class="line">    return _arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arguments通过懒加载获取，组装成数组的过程比较昂贵。库中创建了NSInvocation的分类Aspects，新增了<code>aspects_arguments</code>和<code>aspect_argumentAtIndex:</code>2个实例方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation NSInvocation (Aspects)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Thanks to the ReactiveCocoa team for providing a generic solution for this.</span><br><span class="line">- (id)aspect_argumentAtIndex:(NSUInteger)index &#123;</span><br><span class="line">	const char *argType &#x3D; [self.methodSignature getArgumentTypeAtIndex:index];</span><br><span class="line">	&#x2F;&#x2F; Skip const type qualifier.</span><br><span class="line">	if (argType[0] &#x3D;&#x3D; _C_CONST) argType++;</span><br><span class="line"></span><br><span class="line">#define WRAP_AND_RETURN(type) do &#123; type val &#x3D; 0; [self getArgument:&amp;val atIndex:(NSInteger)index]; return @(val); &#125; while (0)</span><br><span class="line">	if (strcmp(argType, @encode(id)) &#x3D;&#x3D; 0 || strcmp(argType, @encode(Class)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		__autoreleasing id returnObj;</span><br><span class="line">		[self getArgument:&amp;returnObj atIndex:(NSInteger)index];</span><br><span class="line">		return returnObj;</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(SEL)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        SEL selector &#x3D; 0;</span><br><span class="line">        [self getArgument:&amp;selector atIndex:(NSInteger)index];</span><br><span class="line">        return NSStringFromSelector(selector);</span><br><span class="line">    &#125; else if (strcmp(argType, @encode(Class)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        __autoreleasing Class theClass &#x3D; Nil;</span><br><span class="line">        [self getArgument:&amp;theClass atIndex:(NSInteger)index];</span><br><span class="line">        return theClass;</span><br><span class="line">        &#x2F;&#x2F; Using this list will box the number with the appropriate constructor, instead of the generic NSValue.</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(char)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(char);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(int)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(int);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(short)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(short);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(long long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(long long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned char)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned char);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned int)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned int);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned short)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned short);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(unsigned long long)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(unsigned long long);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(float)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(float);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(double)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(double);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(BOOL)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(BOOL);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(bool)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(BOOL);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(char *)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		WRAP_AND_RETURN(const char *);</span><br><span class="line">	&#125; else if (strcmp(argType, @encode(void (^)(void))) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		__unsafe_unretained id block &#x3D; nil;</span><br><span class="line">		[self getArgument:&amp;block atIndex:(NSInteger)index];</span><br><span class="line">		return [block copy];</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		NSUInteger valueSize &#x3D; 0;</span><br><span class="line">		NSGetSizeAndAlignment(argType, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">		unsigned char valueBytes[valueSize];</span><br><span class="line">		[self getArgument:valueBytes atIndex:(NSInteger)index];</span><br><span class="line"></span><br><span class="line">		return [NSValue valueWithBytes:valueBytes objCType:argType];</span><br><span class="line">	&#125;</span><br><span class="line">	return nil;</span><br><span class="line">#undef WRAP_AND_RETURN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)aspects_arguments &#123;</span><br><span class="line">	NSMutableArray *argumentsArray &#x3D; [NSMutableArray array];</span><br><span class="line">	for (NSUInteger idx &#x3D; 2; idx &lt; self.methodSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">		[argumentsArray addObject:[self aspect_argumentAtIndex:idx] ?: NSNull.null];</span><br><span class="line">	&#125;</span><br><span class="line">	return [argumentsArray copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>aspect_argumentAtIndex:</code>大体上通过C函数strcmp判断参数类型是否相等，来获取对应index的参数，在<code>aspects_arguments</code>中组装到argumentArray中并返回。这里作者感谢ReactiveCocoa团队提供的通用解决方案。</p>
<p>###AspectIdentifier</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks a single aspect.</span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectIdentifier持有hook相关的信息，注意这里object是用weak修饰，即对hook对象弱引用。让我们看看初始化方法<code>identifierWithSelector:object:options:block:error:</code>的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error &#123;</span><br><span class="line">    NSCParameterAssert(block);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line">    NSMethodSignature *blockSignature &#x3D; aspect_blockMethodSignature(block, error); &#x2F;&#x2F; TODO: check signature compatibility, etc.</span><br><span class="line">    if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AspectIdentifier *identifier &#x3D; nil;</span><br><span class="line">    if (blockSignature) &#123;</span><br><span class="line">        identifier &#x3D; [AspectIdentifier new];</span><br><span class="line">        identifier.selector &#x3D; selector;</span><br><span class="line">        identifier.block &#x3D; block;</span><br><span class="line">        identifier.blockSignature &#x3D; blockSignature;</span><br><span class="line">        identifier.options &#x3D; options;</span><br><span class="line">        identifier.object &#x3D; object; &#x2F;&#x2F; weak</span><br><span class="line">    &#125;</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aspect_blockMethodSignature</code>获取blockSignature，然后判断与原始函数实现的兼容性，初始化identifier以及其属性并返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123;</span><br><span class="line">    AspectBlockRef layout &#x3D; (__bridge void *)block;</span><br><span class="line">	if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t contain a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	void *desc &#x3D; layout-&gt;descriptor;</span><br><span class="line">	desc +&#x3D; 2 * sizeof(unsigned long int);</span><br><span class="line">	if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">		desc +&#x3D; 2 * sizeof(void *);</span><br><span class="line">    &#125;</span><br><span class="line">	if (!desc) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t has a type signature.&quot;, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	const char *signature &#x3D; (*(const char **)desc);</span><br><span class="line">	return [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aspect_blockMethodSignature</code>主要步骤如下：</p>
<p>1.强转block为自定义的AspectBlockRef类型指针</p>
<p>2.通过与运算<code>layout-&gt;flags &amp; AspectBlockFlagsHasSignature</code>判断当前block是否包含签名</p>
<p>3.获取<code>layout-&gt;descriptor</code>的指针desc，指针地址加上 <code>2 * sizeof(unsigned long int)</code>，即reserved和size占用的内存地址大小</p>
<p>4.通过与运算<code>layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers</code>判断当前block是否拷贝到堆上，若成立，则desc指针地址再加上 <code>2 * sizeof(void *)</code>，即copy和dispose占用的内存地址大小</p>
<p>5.判断desc是否有值，通过<code>[NSMethodSignature signatureWithObjCTypes:]</code>返回签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Block internals.</span><br><span class="line">typedef NS_OPTIONS(int, AspectBlockFlags) &#123;</span><br><span class="line">	AspectBlockFlagsHasCopyDisposeHelpers &#x3D; (1 &lt;&lt; 25),</span><br><span class="line">	AspectBlockFlagsHasSignature          &#x3D; (1 &lt;&lt; 30)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你阅读过Block的<a href="https://opensource.apple.com/source/libclosure/libclosure-73/Block_private.h.auto.html" target="_blank" rel="noopener">源码</a>，可以发现这里的枚举跟<code>Block_layout-&gt;flags</code>中<code>BLOCK_HAS_COPY_DISPOSE</code>和<code>BLOCK_HAS_SIGNATURE</code>值相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _AspectBlock &#123;</span><br><span class="line">	__unused Class isa;</span><br><span class="line">	AspectBlockFlags flags;</span><br><span class="line">	__unused int reserved;</span><br><span class="line">	void (__unused *invoke)(struct _AspectBlock *block, ...);</span><br><span class="line">	struct &#123;</span><br><span class="line">		unsigned long int reserved;</span><br><span class="line">		unsigned long int size;</span><br><span class="line">		&#x2F;&#x2F; requires AspectBlockFlagsHasCopyDisposeHelpers</span><br><span class="line">		void (*copy)(void *dst, const void *src);</span><br><span class="line">		void (*dispose)(const void *);</span><br><span class="line">		&#x2F;&#x2F; requires AspectBlockFlagsHasSignature</span><br><span class="line">		const char *signature;</span><br><span class="line">		const char *layout;</span><br><span class="line">	&#125; *descriptor;</span><br><span class="line">	&#x2F;&#x2F; imported variables</span><br><span class="line">&#125; *AspectBlockRef;</span><br></pre></td></tr></table></figure>

<p>AspectBlockRef跟源码中Block的结构体Block_layout的定义也是一致的。<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes" target="_blank" rel="noopener">__unused</a>代表这个函数或者变量可能不使用，避免产生GCC编译器警告。</p>
<p>回到<code>identifierWithSelector:object:options:block:error:</code>方法中，接下来通过<code>aspect_isCompatibleBlockSignature</code>判断block参数与原始SEL参数的兼容性，不兼容则返回nil。然后给实例对象identifier各个属性赋值并返回identifier，AspectIdentifier的初始化方法到此结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(blockSignature);</span><br><span class="line">    NSCParameterAssert(object);</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line"></span><br><span class="line">    BOOL signaturesMatch &#x3D; YES;</span><br><span class="line">    NSMethodSignature *methodSignature &#x3D; [[object class] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    if (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果block的参数数量大于原方法的参数数量，不匹配</span><br><span class="line">        signaturesMatch &#x3D; NO;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if (blockSignature.numberOfArguments &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果block的参数数量大于1，即有id&lt;AspectInfo&gt;，取出并对比&#39;@&#39;，不是一个对象类型，就不匹配</span><br><span class="line">            const char *blockType &#x3D; [blockSignature getArgumentTypeAtIndex:1];</span><br><span class="line">            if (blockType[0] !&#x3D; &#39;@&#39;) &#123;</span><br><span class="line">                signaturesMatch &#x3D; NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对于 method，参数0位是 self，参数1位是 SEL。对于 blockSignature，参数0位是 block，参数1位是 id&lt;AspectInfo&gt;。我们从参数2位开始做比较。</span><br><span class="line">        &#x2F;&#x2F; block 的参数数量可以少于 method，没事儿。</span><br><span class="line">        if (signaturesMatch) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果以上都符合，那么从第2位参数开始对比数据类型</span><br><span class="line">            for (NSUInteger idx &#x3D; 2; idx &lt; blockSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">                const char *methodType &#x3D; [methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                const char *blockType &#x3D; [blockSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                &#x2F;&#x2F; 不能是可选数据类型</span><br><span class="line">                if (!methodType || !blockType || methodType[0] !&#x3D; blockType[0]) &#123;</span><br><span class="line">                    signaturesMatch &#x3D; NO; break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!signaturesMatch) &#123;</span><br><span class="line">        NSString *description &#x3D; [NSString stringWithFormat:@&quot;Block signature %@ doesn&#39;t match %@.&quot;, blockSignature, methodSignature];</span><br><span class="line">        AspectError(AspectErrorIncompatibleBlockSignature, description);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-(BOOL)invokeWithInfo:(id\&lt;AspectInfo&gt;)info</code>方法即调用hook的block代码。这里再次检查了一遍参数数量（其实没必要），并从2位开始，逐一把原函数中的参数赋给blockInvocation，最后invokeWithTarget调用block的函数实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    NSInvocation *blockInvocation &#x3D; [NSInvocation invocationWithMethodSignature:self.blockSignature];</span><br><span class="line">    NSInvocation *originalInvocation &#x3D; info.originalInvocation;</span><br><span class="line">    NSUInteger numberOfArguments &#x3D; self.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 谨慎起见，我们也要检查挂钩注册（参数数量）</span><br><span class="line">    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; blockInvocation 中的 &#39;self&#39; 实际将是 AspectInfo (可选)</span><br><span class="line">    if (numberOfArguments &gt; 1) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	void *argBuf &#x3D; NULL;</span><br><span class="line">    for (NSUInteger idx &#x3D; 2; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        const char *type &#x3D; [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">		NSUInteger argSize;</span><br><span class="line">		NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line">        </span><br><span class="line">		if (!(argBuf &#x3D; reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);</span><br><span class="line">			return NO;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [blockInvocation invokeWithTarget:self.block];</span><br><span class="line">    </span><br><span class="line">    if (argBuf !&#x3D; NULL) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，一般的方法调用在运行时是通过消息转发机制来完成，即<a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">[receiver message]</a>的形式，最终都转换成<code>objc_msgSend(receiver, @selector(message))</code>这样的纯C调用。但是，block并没有实际意义上的selector，运行时该如何调用block函数实现呢。没错，就是通过<code>[NSInvocation invocationWithMethodSignature:]</code>和<code>[NSInvocation invokeWithTarget:]</code>2个方法，获取到block的<a href="https://www.jianshu.com/p/1849068b7833" target="_blank" rel="noopener">signature</a>后，生成blockInvocation对象，再来调用block。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)remove &#123;</span><br><span class="line">    return aspect_remove(self, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循&lt;AspectToken&gt;协议实现了remove方法。</p>
<h3 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks all aspects for an object&#x2F;class.</span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectsContainer是AspectIdentifier的容器。主要是存储一个对象或者一个类的所有Aspects hook代码。可以注意到这里用到了atomic原子性修饰3个AspectsArray（方法执行前/替换方法实现/方法执行后），保证3个Array的set、get方法读写安全。接下来我们看看AspectsContainer具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AspectsContainer</span><br><span class="line"></span><br><span class="line">- (BOOL)hasAspects &#123;</span><br><span class="line">    return self.beforeAspects.count &gt; 0 || self.insteadAspects.count &gt; 0 || self.afterAspects.count &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123;</span><br><span class="line">    NSParameterAssert(aspect);</span><br><span class="line">    NSUInteger position &#x3D; options&amp;AspectPositionFilter;</span><br><span class="line">    switch (position) &#123;</span><br><span class="line">        case AspectPositionBefore:  self.beforeAspects  &#x3D; [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">        case AspectPositionInstead: self.insteadAspects &#x3D; [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">        case AspectPositionAfter:   self.afterAspects   &#x3D; [(self.afterAspects  ?:@[]) arrayByAddingObject:aspect]; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)removeAspect:(id)aspect &#123;</span><br><span class="line">    for (NSString *aspectArrayName in @[NSStringFromSelector(@selector(beforeAspects)),</span><br><span class="line">                                        NSStringFromSelector(@selector(insteadAspects)),</span><br><span class="line">                                        NSStringFromSelector(@selector(afterAspects))]) &#123;</span><br><span class="line">        NSArray *array &#x3D; [self valueForKey:aspectArrayName];</span><br><span class="line">        NSUInteger index &#x3D; [array indexOfObjectIdenticalTo:aspect];</span><br><span class="line">        if (array &amp;&amp; index !&#x3D; NSNotFound) &#123;</span><br><span class="line">            NSMutableArray *newArray &#x3D; [NSMutableArray arrayWithArray:array];</span><br><span class="line">            [newArray removeObjectAtIndex:index];</span><br><span class="line">            [self setValue:newArray forKey:aspectArrayName];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, before:%@, instead:%@, after:%@&gt;&quot;, self.class, self, self.beforeAspects, self.insteadAspects, self.afterAspects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>hasAspects返回当前对象或者类对象是否有Aspects hook代码。</p>
<p>在<code>addAspects:withOptions:</code>实现中，通过与运算获取AspectOptions，set方法保证读写安全赋值给对应的AspectsArray。</p>
<p>在<code>removeAspect:</code>实现中，遍历3个array，KVC获取与设置array的值。用到了<a href="https://developer.apple.com/documentation/foundation/nsarray/1410847-indexofobjectidenticalto?language=objc" target="_blank" rel="noopener">indexOfObjectIdenticalTo:</a>快速获取aspect所在索引。相对于<code>indexOfObject:</code>，<code>indexOfObjectIdenticalTo:</code><a href="https://stackoverflow.com/questions/3167849/indexofobject-vs-indexofobjectidenticalto" target="_blank" rel="noopener">更快</a>(直接比较地址，而indexOfObject有个isEqual的过程)。</p>
<p>这里有个疑问，既然用atomic保证原子性，<code>addAspects:withOptions:</code>通过set方法保证了读写安全，<code>removeAspect:</code>中则用到了KVC来获取与重新赋值array，为什么不继续使用set、get方法来保证读写安全呢？</p>
<p>###AspectTracker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface AspectTracker : NSObject</span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass;</span><br><span class="line">@property (nonatomic, strong) Class trackedClass;</span><br><span class="line">@property (nonatomic, readonly) NSString *trackedClassName;</span><br><span class="line">@property (nonatomic, strong) NSMutableSet *selectorNames;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;</span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;</span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AspectTracker顾名思义是切面追踪器。主要功能是为了判断当前类对象是否可以被hook，并对允许hook的类添加追踪器以便再次判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123;</span><br><span class="line">    static NSMutableDictionary *swizzledClassesDict;</span><br><span class="line">    static dispatch_once_t pred;</span><br><span class="line">    dispatch_once(&amp;pred, ^&#123;</span><br><span class="line">        swizzledClassesDict &#x3D; [NSMutableDictionary new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return swizzledClassesDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追踪器存储在静态变量swizzledClassesDict中，通过dispatch_once创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AspectTracker</span><br><span class="line"></span><br><span class="line">- (id)initWithTrackedClass:(Class)trackedClass &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        _trackedClass &#x3D; trackedClass;</span><br><span class="line">        _selectorNames &#x3D; [NSMutableSet new];</span><br><span class="line">        _selectorNamesToSubclassTrackers &#x3D; [NSMutableDictionary new];&#x2F;&#x2F; &lt;NSString: NSMutableSet&lt;AspectTracker&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    return self.selectorNamesToSubclassTrackers[selectorName] !&#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *trackerSet &#x3D; self.selectorNamesToSubclassTrackers[selectorName];</span><br><span class="line">    if (!trackerSet) &#123;</span><br><span class="line">        trackerSet &#x3D; [NSMutableSet new];</span><br><span class="line">        self.selectorNamesToSubclassTrackers[selectorName] &#x3D; trackerSet;</span><br><span class="line">    &#125;</span><br><span class="line">    [trackerSet addObject:subclassTracker];</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *trackerSet &#x3D; self.selectorNamesToSubclassTrackers[selectorName];</span><br><span class="line">    [trackerSet removeObject:subclassTracker];</span><br><span class="line">    if (trackerSet.count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        [self.selectorNamesToSubclassTrackers removeObjectForKey:selectorName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName &#123;</span><br><span class="line">    NSMutableSet *hookingSubclassTrackers &#x3D; [NSMutableSet new];</span><br><span class="line">    &#x2F;&#x2F;递归获取所有当前类的子类相对于该SEL的跟踪器，若tracker.selectorNames包含该SEL name，则添加到hookingSubclassTrackers集合中</span><br><span class="line">    for (AspectTracker *tracker in self.selectorNamesToSubclassTrackers[selectorName]) &#123;</span><br><span class="line">        if ([tracker.selectorNames containsObject:selectorName]) &#123;</span><br><span class="line">            [hookingSubclassTrackers addObject:tracker];</span><br><span class="line">        &#125;</span><br><span class="line">        [hookingSubclassTrackers unionSet:[tracker subclassTrackersHookingSelectorName:selectorName]];</span><br><span class="line">    &#125;</span><br><span class="line">    return hookingSubclassTrackers;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)trackedClassName &#123;</span><br><span class="line">    return NSStringFromClass(self.trackedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %@, trackedClass: %@, selectorNames:%@, subclass selector names: %@&gt;&quot;, self.class, self, NSStringFromClass(self.trackedClass), self.selectorNames, self.selectorNamesToSubclassTrackers.allKeys];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>initWithTrackedClass:</code>传入类初始化AspectTracker，<code>_trackedClass</code>为当前跟踪的类，用于trackedClassName方法返回类名；<code>_selectorNames</code>存储在当前类hook的selectorName； <code>_selectorNamesToSubclassTrackers</code>结构为<code>&lt;NSString: NSMutableSet&lt;AspectTracker&gt;&gt;</code>，即key为selectorName，value为<code>NSMutableSet&lt;AspectTracker&gt;</code>(所有子类对该SEL的追踪器)的可变字典。</p>
<p><code>subclassHasHookedSelectorName:</code>判断当前SEL是否在子类被Hook。</p>
<p><code>addSubclassTracker:hookingSelectorName:</code>添加子类SEL追踪器到字典selectorNamesToSubclassTrackers。</p>
<p><code>removeSubclassTracker:hookingSelectorName:</code>删除子类SEL追踪器。若追踪器set集合count为0，从字典selectorNamesToSubclassTrackers删除key(selectorName)对应NSMutableSet。</p>
<p><code>subclassTrackersHookingSelectorName</code>用来获取当前SEL的所有源追踪器，也就是说获取当前SEL在哪些子类被hook。</p>
<p>追踪器的实现比较绕，分为2种：</p>
<p>1.在当前类被hook的话，添加到selectorNames中；</p>
<p>2.在当前类的子类被hook的话，添加到selectorNamesToSubclassTrackers中。</p>
<p>以下是AspectTracker追踪器在<code>aspect_isSelectorAllowedAndTrack</code>方法中的实现流程图，建议结合代码理解。</p>
<p><img src="https://i.loli.net/2019/12/23/a5dH6kqmGEXi8b4.png" alt="Aspects-AspectTracker实现原理.jpg"></p>
<p>###aspect_isMsgForwardIMP和aspect_getMsgForwardIMP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BOOL aspect_isMsgForwardIMP(IMP impl) &#123;</span><br><span class="line">    return impl &#x3D;&#x3D; _objc_msgForward</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line">    || impl &#x3D;&#x3D; (IMP)_objc_msgForward_stret</span><br><span class="line">#endif</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) &#123;</span><br><span class="line">    IMP msgForwardIMP &#x3D; _objc_msgForward;</span><br><span class="line">#if !defined(__arm64__)</span><br><span class="line">    &#x2F;&#x2F; As an ugly internal runtime implementation detail in the 32bit runtime, we need to determine of the method we hook returns a struct or anything larger than id.</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;mac&#x2F;documentation&#x2F;DeveloperTools&#x2F;Conceptual&#x2F;LowLevelABI&#x2F;000-Introduction&#x2F;introduction.html</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ReactiveCocoa&#x2F;ReactiveCocoa&#x2F;issues&#x2F;783</span><br><span class="line">    &#x2F;&#x2F; http:&#x2F;&#x2F;infocenter.arm.com&#x2F;help&#x2F;topic&#x2F;com.arm.doc.ihi0042e&#x2F;IHI0042E_aapcs.pdf (Section 5.4)</span><br><span class="line">    Method method &#x3D; class_getInstanceMethod(self.class, selector);</span><br><span class="line">    const char *encoding &#x3D; method_getTypeEncoding(method);</span><br><span class="line">    BOOL methodReturnsStructValue &#x3D; encoding[0] &#x3D;&#x3D; _C_STRUCT_B;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            NSUInteger valueSize &#x3D; 0;</span><br><span class="line">            NSGetSizeAndAlignment(encoding, &amp;valueSize, NULL);</span><br><span class="line"></span><br><span class="line">            if (valueSize &#x3D;&#x3D; 1 || valueSize &#x3D;&#x3D; 2 || valueSize &#x3D;&#x3D; 4 || valueSize &#x3D;&#x3D; 8) &#123;</span><br><span class="line">                methodReturnsStructValue &#x3D; NO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @catch (__unused NSException *e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodReturnsStructValue) &#123;</span><br><span class="line">        msgForwardIMP &#x3D; (IMP)_objc_msgForward_stret;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return msgForwardIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aspects中，arm64CPU架构下只用_objc_msgForward，建议看这篇<a href="https://juejin.im/post/5a459f6c51882538fe6316d5" target="_blank" rel="noopener">文章</a>理解。这2个函数实现主要在<code>aspect_prepareClassAndHookSelector</code>中用到，通过将selector对应IMP替换成 _objc_msgForward或者 _objc_msgForward_stret，可以触发消息转发，从而进入forwardInvocation的实现。</p>
<h3 id="aspect-invoke"><a href="#aspect-invoke" class="headerlink" title="aspect_invoke"></a>aspect_invoke</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define aspect_invoke(aspects, info) \</span><br><span class="line">for (AspectIdentifier *aspect in aspects) &#123;\</span><br><span class="line">    [aspect invokeWithInfo:info];\</span><br><span class="line">    if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span><br><span class="line">        aspectsToRemove &#x3D; [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者为了调试方便，把调用hook代码的过程替换成一个多行的宏定义。</p>
<p>接下来的部分将涉及到aspect_hookClass等的实现原理，由于篇幅过长，下一篇再进行分析。</p>
<p>这里是3篇比较好的文章：</p>
<p><a href="http://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">面向切面编程之 Aspects 源码解析及应用</a></p>
<p><a href="[https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%E4%B8%8EAspects%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md](https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/消息转发机制与Aspects源码解析.md)">消息转发机制与Aspects源码解析</a></p>
<p><a href="https://halfrost.com/ios_aspect/" target="_blank" rel="noopener">iOS如何实现 Aspect Oriented Programming</a></p>
<p>另：流程图、思维导图用<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>在线作图。</p>
]]></content>
  </entry>
</search>
